<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dreammilk.now.sh</id>
    <title>Milk &apos;s Home</title>
    <updated>2020-06-19T04:15:15.625Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dreammilk.now.sh"/>
    <link rel="self" href="https://dreammilk.now.sh/atom.xml"/>
    <subtitle>welcome</subtitle>
    <logo>https://dreammilk.now.sh/images/avatar.png</logo>
    <icon>https://dreammilk.now.sh/favicon.ico</icon>
    <rights>All rights reserved 2020, Milk &apos;s Home</rights>
    <entry>
        <title type="html"><![CDATA[[需复盘]1084 外观数列 (20分)]]></title>
        <id>https://dreammilk.now.sh/xu-fu-pan-1084-wai-guan-shu-lie-20-fen/</id>
        <link href="https://dreammilk.now.sh/xu-fu-pan-1084-wai-guan-shu-lie-20-fen/">
        </link>
        <updated>2020-06-19T04:10:56.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>外观数列是指具有以下特点的整数序列：</p>
<pre><code>d, d1, d111, d113, d11231, d112213111, ...
</code></pre>
<p>它从不等于 1 的数字 <code>d</code> 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 <code>d</code>，所以就是 <code>d1</code>；第 2 项是 1 个 <code>d</code>（对应 <code>d1</code>）和 1 个 1（对应 11），所以第 3 项就是 <code>d111</code>。又比如第 4 项是 <code>d113</code>，其描述就是 1 个 <code>d</code>，2 个 1，1 个 3，所以下一项就是 <code>d11231</code>。当然这个定义对 <code>d</code> = 1 也成立。本题要求你推算任意给定数字 <code>d</code> 的外观数列的第 N 项。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>外观数列是指具有以下特点的整数序列：</p>
<pre><code>d, d1, d111, d113, d11231, d112213111, ...
</code></pre>
<p>它从不等于 1 的数字 <code>d</code> 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 <code>d</code>，所以就是 <code>d1</code>；第 2 项是 1 个 <code>d</code>（对应 <code>d1</code>）和 1 个 1（对应 11），所以第 3 项就是 <code>d111</code>。又比如第 4 项是 <code>d113</code>，其描述就是 1 个 <code>d</code>，2 个 1，1 个 3，所以下一项就是 <code>d11231</code>。当然这个定义对 <code>d</code> = 1 也成立。本题要求你推算任意给定数字 <code>d</code> 的外观数列的第 N 项。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出 [0,9] 范围内的一个整数 <code>d</code>、以及一个正整数 N（≤ 40），用空格分隔。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中给出数字 <code>d</code> 的外观数列的第 N 项。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">1 8
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">1123123111
</code></pre>
<h3 id="思路">思路：</h3>
<p>目前没有理解为什么会出现测试点无法通过的点</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n;
    string d;
    cin &gt;&gt; d &gt;&gt; n;
    for(int i=1;i&lt;n;i++){
        string str=&quot;&quot;;
        char temp = d[0];int cnt = 1;
        for(int j=1;j&lt;d.length();j++){
            if(d[j]==temp) cnt++;
            else{
                str = str+temp+char('0'+cnt);
                cnt = 1;
                temp=d[j];
            }
        }
        str = str+temp+char('0'+cnt);
        d = str;
    }
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>修改后：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    string s;
    int n, j;
    cin &gt;&gt; s &gt;&gt; n;
    for (int cnt = 1; cnt &lt; n; cnt++) {
        string t;
        for (int i = 0; i &lt; s.length(); i = j) {
            for (j = i; j &lt; s.length() &amp;&amp; s[j] == s[i]; j++);
            t += s[i] + to_string(j - i);
        }
        s = t;
    }
    cout &lt;&lt; s;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1082 射击比赛 (20分)]]></title>
        <id>https://dreammilk.now.sh/1082-she-ji-bi-sai-20-fen/</id>
        <link href="https://dreammilk.now.sh/1082-she-ji-bi-sai-20-fen/">
        </link>
        <updated>2020-06-18T04:07:31.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出：</p>
<pre><code>ID x y
</code></pre>
<p>其中 <code>ID</code> 是运动员的编号（由 4 位数字组成）；<code>x</code> 和 <code>y</code> 是其打出的弹洞的平面坐标(<code>x</code>,<code>y</code>)，均为整数，且 0 ≤ |<code>x</code>|, |<code>y</code>| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">3
0001 5 7
1020 -1 3
0233 0 -1
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">0233 0001
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目主要还是找最大最小值：</p>
<blockquote>
<p>对于距离还是直接使用<code>x*x+y*y</code>进行比较</p>
<p>找到最大最小值时需要保存他们的id</p>
<p>最后直接输出最小值id与最大值id</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n,MAX=0,MIN=10000,maxid,minid;
    cin &gt;&gt; n;
    for(int i=0;i&lt;n;i++){
        int id,x,y,length;
        cin &gt;&gt; id &gt;&gt; x &gt;&gt; y;
        length = x*x+y*y;
        if(length &gt; MAX){
            MAX = length;
            maxid = id;
        }
        if(length &lt; MIN){
            MIN = length;
            minid = id;
        }
    }
    printf(&quot;%04d %04d&quot;,minid,maxid);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1081 检查密码 (15分)]]></title>
        <id>https://dreammilk.now.sh/1081-jian-cha-mi-ma-15-fen/</id>
        <link href="https://dreammilk.now.sh/1081-jian-cha-mi-ma-15-fen/">
        </link>
        <updated>2020-06-17T04:16:44.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 <code>.</code>，还必须既有字母也有数字。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 <code>.</code>，还必须既有字母也有数字。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对每个用户的密码，在一行中输出系统反馈信息，分以下5种：</p>
<ul>
<li>如果密码合法，输出<code>Your password is wan mei.</code>；</li>
<li>如果密码太短，不论合法与否，都输出<code>Your password is tai duan le.</code>；</li>
<li>如果密码长度合法，但存在不合法字符，则输出<code>Your password is tai luan le.</code>；</li>
<li>如果密码长度合法，但只有字母没有数字，则输出<code>Your password needs shu zi.</code>；</li>
<li>如果密码长度合法，但只有数字没有字母，则输出<code>Your password needs zi mu.</code>。</li>
</ul>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">5
123s
zheshi.wodepw
1234.5678
WanMei23333
pass*word.6
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">Your password is tai duan le.
Your password needs shu zi.
Your password needs zi mu.
Your password is wan mei.
Your password is tai luan le.
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目的输出格式将逻辑展示的非常清楚：</p>
<blockquote>
<p>对每一个字符串，首先判断字符长度，过短则输出</p>
<p>对字符串的每一个字符进行判断，使用<code>bool</code>变量检测数字和字母是否出现（在字符遍历完后判断）</p>
<p>如果出现不规范的字符则直接停止字符遍历，进行输出；否则继续遍历</p>
</blockquote>
<p>注意一点：</p>
<blockquote>
<p>题目虽然没有明确提醒输入时会有空格，但是需要考虑这种情况，避免测试点无法通过</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cctype&gt;

using namespace std;

int main() {
    int n;
    scanf(&quot;%d\n&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        string str;
        getline(cin,str);
        if(str.length() &lt; 6){
            cout &lt;&lt; &quot;Your password is tai duan le.&quot; &lt;&lt; endl;
            continue;
        }
        else{
            int j;
            bool number=true,alpha=true;
            for(j=0;j&lt;str.length();j++){
                if(isdigit(str[j])) number=false;
                else if(isalpha(str[j])) alpha = false;
                else if(str[j]=='.') continue;
                else{
                    cout &lt;&lt; &quot;Your password is tai luan le.&quot; &lt;&lt; endl;
                    break;
                }
            }
            if(j!=str.length()) continue;
            if(number){
                cout &lt;&lt; &quot;Your password needs shu zi.&quot; &lt;&lt; endl;
                continue;
            }
            if(alpha){
                cout &lt;&lt; &quot;Your password needs zi mu.&quot; &lt;&lt; endl;
                continue;
            }
            cout &lt;&lt; &quot;Your password is wan mei.&quot; &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1079 延迟的回文数 (20分)]]></title>
        <id>https://dreammilk.now.sh/1079-yan-chi-de-hui-wen-shu-20-fen/</id>
        <link href="https://dreammilk.now.sh/1079-yan-chi-de-hui-wen-shu-20-fen/">
        </link>
        <updated>2020-06-15T03:30:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个 <em>k</em>+1 位的正整数 <em>N</em>，写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>⋯<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_1a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的形式，其中对所有 <em>i</em> 有 0≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&lt;10 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&gt;0。<em>N</em> 被称为一个<strong>回文数</strong>，当且仅当对所有 <em>i</em> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>−<em>i</em>。零也被定义为一个回文数。</p>
<p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为<strong>延迟的回文数</strong>。（定义翻译自 https://en.wikipedia.org/wiki/Palindromic_number ）</p>
<p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个 <em>k</em>+1 位的正整数 <em>N</em>，写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>⋯<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_1a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的形式，其中对所有 <em>i</em> 有 0≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&lt;10 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&gt;0。<em>N</em> 被称为一个<strong>回文数</strong>，当且仅当对所有 <em>i</em> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>−<em>i</em>。零也被定义为一个回文数。</p>
<p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为<strong>延迟的回文数</strong>。（定义翻译自 https://en.wikipedia.org/wiki/Palindromic_number ）</p>
<p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在一行中给出一个不超过1000位的正整数。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对给定的整数，一行一行输出其变出回文数的过程。每行格式如下</p>
<pre><code class="language-markdown">A + B = C
</code></pre>
<p>其中 <code>A</code> 是原始的数字，<code>B</code> 是 <code>A</code> 的逆转数，<code>C</code> 是它们的和。<code>A</code> 从输入的整数开始。重复操作直到 <code>C</code> 在 10 步以内变成回文数，这时在一行中输出 <code>C is a palindromic number.</code>；或者如果 10 步都没能得到回文数，最后就在一行中输出 <code>Not found in 10 iterations.</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">97152
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">97152 + 25179 = 122331
122331 + 133221 = 255552
255552 is a palindromic number.
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">196
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">196 + 691 = 887
887 + 788 = 1675
1675 + 5761 = 7436
7436 + 6347 = 13783
13783 + 38731 = 52514
52514 + 41525 = 94039
94039 + 93049 = 187088
187088 + 880781 = 1067869
1067869 + 9687601 = 10755470
10755470 + 07455701 = 18211171
Not found in 10 iterations.
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目隐藏的意思：</p>
<blockquote>
<p>如果输入的数字就是回文数的话，直接输出<code>C is a palindromic number.</code></p>
</blockquote>
<p>大致过程：</p>
<blockquote>
<p>进行10次循环，每次先对输入字符串判断是否为回文数，如果是则退出，否则下一步</p>
<p>然后输出等式并将字符串与反转字符串相加，得到新的字符串</p>
<p>结束循环后判断是否是中途退出循环，如果是则符合回文要求，否则不能得到回文数</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    string input,str;
    cin &gt;&gt; str;
    int i;
    for(i=0;i&lt;10;i++){
        input = str;
        reverse(str.begin(),str.end());
        if(input == str){
            cout &lt;&lt; input &lt;&lt; &quot; is a palindromic number.&quot;;
            break;
        }
        cout &lt;&lt; input &lt;&lt; &quot; + &quot;;

        cout &lt;&lt; str &lt;&lt; &quot; = &quot;;
        int up=0;str=&quot;&quot;;
        for(int j=0;j&lt;input.length();j++){
            char c;
            int num=input[j]+input[input.length()-1-j]-2*'0'+up;
            c = num%10+'0';
            up = num/10;
            str = c+str;
        }
        if(up!=0) str = &quot;1&quot;+str;
        cout &lt;&lt; str &lt;&lt; endl;
    }
    if(i==10) cout &lt;&lt; &quot;Not found in 10 iterations.&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1078 字符串压缩与解压 (20分)]]></title>
        <id>https://dreammilk.now.sh/1078-zi-fu-chuan-ya-suo-yu-jie-ya-20-fen/</id>
        <link href="https://dreammilk.now.sh/1078-zi-fu-chuan-ya-suo-yu-jie-ya-20-fen/">
        </link>
        <updated>2020-06-14T04:25:53.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 <code>ccccc</code> 就用 <code>5c</code> 来表示。如果字符没有重复，就原样输出。例如 <code>aba</code> 压缩后仍然是 <code>aba</code>。</p>
<p>解压方法就是反过来，把形如 <code>5c</code> 这样的表示恢复为 <code>ccccc</code>。</p>
<p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 <code>ccccc</code> 就用 <code>5c</code> 来表示。如果字符没有重复，就原样输出。例如 <code>aba</code> 压缩后仍然是 <code>aba</code>。</p>
<p>解压方法就是反过来，把形如 <code>5c</code> 这样的表示恢复为 <code>ccccc</code>。</p>
<p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个字符，如果是 <code>C</code> 就表示下面的字符串需要被压缩；如果是 <code>D</code> 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>根据要求压缩或解压字符串，并在一行中输出结果。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">C
TTTTThhiiiis isssss a   tesssst CAaaa as
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">5T2h4is i5s a3 te4st CA3a as
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">D
5T2h4is i5s a3 te4st CA3a as10Z
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">TTTTThhiiiis isssss a   tesssst CAaaa asZZZZZZZZZZ
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>在压缩字符串时存在两个变量，<code>temp</code>和<code>cnt</code>分别是前一个字母与出现次数</p>
<p>如果当前字母与<code>temp</code>不同，则输出<code>cnt</code>和<code>temp</code>，如果<code>cnt</code>为1则省略；不同时<code>cnt++</code></p>
<p>在解压字符串时需要注意连续出现数字的情况，这些数字需要变为一个整体</p>
<p>然后每次输出时循环打印即可</p>
</blockquote>
<p>需要注意输入输出的格式问题，避免存储错误信息</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cctype&gt;

using namespace std;

int main() {
    char c;
    string s;
    int cnt=0;
    cin &gt;&gt; c;
    getchar();
    getline(cin,s);
    if(c=='C'){
        char temp = s[0];
        for(int i=1;i&lt;s.length();i++){
            if(s[i]==temp) cnt++;
            else{
                if(cnt==0) cout &lt;&lt; temp;
                else cout &lt;&lt; cnt+1 &lt;&lt; temp;
                temp = s[i];
                cnt = 0;
            }
        }
        if(cnt==0) cout &lt;&lt; temp;
        else cout &lt;&lt; cnt+1 &lt;&lt; temp;
    }
    else{
        for(int i=0;i&lt;s.length();i++){
            if(isdigit(s[i])) cnt = cnt*10 + s[i]-'0';
            else{
                cnt = cnt==0?1:cnt;
                for(int j=0;j&lt;cnt;j++) cout &lt;&lt; s[i];
                cnt = 0;
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1077 互评成绩计算 (20分)]]></title>
        <id>https://dreammilk.now.sh/1077-hu-ping-cheng-ji-ji-suan-20-fen/</id>
        <link href="https://dreammilk.now.sh/1077-hu-ping-cheng-ji-ji-suan-20-fen/">
        </link>
        <updated>2020-06-13T04:49:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 <em>G</em>1；老师给这个组的评分记为 <em>G</em>2。该组得分为 (<em>G</em>1+<em>G</em>2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 <em>G</em>1；老师给这个组的评分记为 <em>G</em>2。该组得分为 (<em>G</em>1+<em>G</em>2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出两个正整数 <em>N</em>（&gt; 3）和 <em>M</em>，分别是分组数和满分，均不超过 100。随后 <em>N</em> 行，每行给出该组得到的 <em>N</em> 个分数（均保证为整型范围内的整数），其中第 1 个是老师给出的评分，后面 <em>N</em>−1 个是其他组给的评分。合法的输入应该是 [0,<em>M</em>] 区间内的整数，若不在合法区间内，则该分数须被忽略。题目保证老师的评分都是合法的，并且每个组至少会有 3 个来自同学的合法评分。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>为每个组输出其最终得分。每个得分占一行。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">6 50
42 49 49 35 38 41
36 51 50 28 -1 30
40 36 41 33 47 49
30 250 -25 27 45 31
48 0 0 50 50 1234
43 41 36 29 42 29
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">42
33
41
31
37
39
</code></pre>
<h3 id="思路">思路：</h3>
<p>唯一需要注意的是计算逻辑，需要看清楚题意：</p>
<blockquote>
<p>对输入的每行数据进行处理，寻找最大最小值，学生有效分数和数量总计，老师分数</p>
<p>计算时可以使用0.5来帮助小数进行四舍五入</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;n;i++){
        int teacher,cnt=0,MAX=0,MIN=m;
        float students=0;
        cin &gt;&gt; teacher;
        for(int j=0;j&lt;n-1;j++){
            int score;
            cin &gt;&gt; score;
            if(score&gt;=0&amp;&amp;score&lt;=m){
                if(score &gt; MAX) MAX = score;
                if(score &lt; MIN) MIN = score;
                students += score;
                cnt++;
            }
        }
        int sum=(teacher+(students-MAX-MIN)/(cnt-2))/2+0.5;
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1076 Wifi密码 (15分)]]></title>
        <id>https://dreammilk.now.sh/1076-wifi-mi-ma-15-fen/</id>
        <link href="https://dreammilk.now.sh/1076-wifi-mi-ma-15-fen/">
        </link>
        <updated>2020-06-12T04:52:45.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
</blockquote>
<!-- more -->
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/7e56be3f-caba-45f1-b9cb-38a96d44de76.jpg" alt="wifi.jpg" loading="lazy"></figure>
</blockquote>
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 <code>编号-答案</code> 的格式给出一道题的 4 个选项，<code>T</code> 表示正确选项，<code>F</code> 表示错误选项。选项间用空格分隔。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出 wifi 密码。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">8
A-T B-F C-F D-F
C-T B-F A-F D-F
A-F D-F C-F B-T
B-T A-F C-F D-F
B-F D-T A-F C-F
A-T C-F B-F D-F
D-T B-F C-F A-F
C-T A-F B-F D-F
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">13224143
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较简单：</p>
<blockquote>
<p>将每一行的输入读入时，判断正确选项并输出对应数字</p>
</blockquote>
<p>稍微注意一下输入：</p>
<blockquote>
<p>每行的回车符号与空格需要吃掉，避免错误读入</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;\n&quot;);
        bool flag=false;
        for(int j=0;j&lt;4;j++){
            char opt,ans;
            if(!flag){
                scanf(&quot;%c-%c&quot;,&amp;opt,&amp;ans);
                flag = true;
            }
            else scanf(&quot; %c-%c&quot;,&amp;opt,&amp;ans);
            if(ans == 'T') printf(&quot;%d&quot;,opt-'A'+1);
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1075 链表元素分类 (25分)]]></title>
        <id>https://dreammilk.now.sh/1075-lian-biao-yuan-su-fen-lei-25-fen/</id>
        <link href="https://dreammilk.now.sh/1075-lian-biao-yuan-su-fen-lei-25-fen/">
        </link>
        <updated>2020-06-11T03:59:35.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>)；以及正整数K (≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>
<p>接下来有 N 行，每行格式为：</p>
<pre><code class="language-in">Address Data Next
</code></pre>
<p>其中 <code>Address</code> 是结点地址；<code>Data</code> 是该结点保存的数据，为 [<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">−10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>] 区间内的整数；<code>Next</code> 是下一结点的地址。题目保证给出的链表不为空。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">00100 9 10
23333 10 27777
00000 0 99999
00100 18 12309
68237 -6 23333
33218 -4 00000
48652 -2 -1
99999 5 68237
27777 11 48652
12309 7 33218
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">33218 -4 68237
68237 -6 48652
48652 -2 12309
12309 7 00000
00000 0 99999
99999 5 23333
23333 10 00100
00100 18 27777
27777 11 -1
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目依旧是按照数组结构的顺序存储：</p>
<blockquote>
<p>构造一个表示结点的结构体，存储数据和下一个结点地址，然后使用数组存放</p>
<p>总共三次循环：第一次存储输入数据；第二次将数据按照大小分类；第三次将每个类中的数据输出</p>
<p>题目的意思是将数据分为（-∞，0）、[0，K]和（K，+∞），保持输入顺序即可</p>
</blockquote>
<p>其实最关键的地方在于输出的处理：</p>
<blockquote>
<p>往常一直是非常死板的认为输出语句最多输出一行的数据，可以保持输出代码比较整洁易读</p>
<p>本题的输出却是输出两行的内容，在输出当前节点时，不需要输出后续节点地址，而是有下一个结点负责补充</p>
<p>这样可以避免产生多余的控制逻辑，提高执行效率</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

struct Node{
    int data,next;
};

int main() {
    int start,n,k;
    Node sqlist[100000];
    scanf(&quot;%d %d %d&quot;,&amp;start,&amp;n,&amp;k);
    for(int i=0;i&lt;n;i++){
        int address;
        scanf(&quot;%d &quot;,&amp;address);
        scanf(&quot;%d %d&quot;,&amp;sqlist[address].data,&amp;sqlist[address].next);
    }
    int p=start;
    vector&lt;int&gt; v[3];
    while(p!=-1){
        if(sqlist[p].data &lt; 0) v[0].push_back(p);
        else if(sqlist[p].data &gt; k) v[2].push_back(p);
        else v[1].push_back(p);
        p = sqlist[p].next;
    }
    bool flag=false;
    for(int i=0;i&lt;3;i++){
        for(int j=0;j&lt;v[i].size();j++){
            if(flag){
                printf(&quot; %05d\n%05d %d&quot;,v[i][j],v[i][j],sqlist[v[i][j]].data);
            }
            else{
                printf(&quot;%05d %d&quot;,v[i][j],sqlist[v[i][j]].data);
                flag = true;
            }
        }
    }
    printf(&quot; -1&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1074 宇宙无敌加法器 (20分)]]></title>
        <id>https://dreammilk.now.sh/1074-yu-zhou-wu-di-jia-fa-qi-20-fen/</id>
        <link href="https://dreammilk.now.sh/1074-yu-zhou-wu-di-jia-fa-qi-20-fen/">
        </link>
        <updated>2020-06-10T04:44:56.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出两个 PAT 数之和。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">30527
06203
415
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">7201
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目没有什么比较绕的地方：</p>
<blockquote>
<p>先将数字都与进制位数对齐，不足的前面补零</p>
<p>然后像题干中的运算过程一样，统计当前位的数字以及是否进位</p>
<p>最后得出运算结果输出即可</p>
</blockquote>
<p>一些需要注意的地方：</p>
<blockquote>
<p>进制中的0是10，使用时需要稍微加工一下</p>
<p>对于首位相加进位，需要记得在结果前面添加<code>1</code>，（PS：两个数相加进位不可能是2）</p>
<p>结果为全零时，需要输出0</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;

int main() {
    string jz,n,m;
    cin &gt;&gt; jz &gt;&gt; n &gt;&gt; m;
    m.insert(0,jz.length()-m.length(),'0');
    n.insert(0,jz.length()-n.length(),'0');
    reverse(n.begin(),n.end());
    reverse(m.begin(),m.end());
    reverse(jz.begin(),jz.end());
    int up=0;string str;
    for(int i=0;i&lt;jz.length();i++){
        int j = jz[i]=='0'?10:jz[i]-'0';
        int num = (n[i]-'0'+m[i]-'0'+up)%j;
        up = (n[i]-'0'+m[i]-'0'+up)/j;
        str.insert(0,1,num+'0');
    }
    if(up!=0) str = '1'+str;
    bool flag = false;
    for(int i=0;i&lt;str.length();i++){
        if(str[i]!='0' || flag){
            flag = true;
            cout &lt;&lt; str[i];
        }
    }
    if(!flag) printf(&quot;0&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1073 多选题常见计分法 (20分)]]></title>
        <id>https://dreammilk.now.sh/1073-duo-xuan-ti-chang-jian-ji-fen-fa-20-fen/</id>
        <link href="https://dreammilk.now.sh/1073-duo-xuan-ti-chang-jian-ji-fen-fa-20-fen/">
        </link>
        <updated>2020-06-09T04:28:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 <code>(选中的选项个数 选项1 ……)</code>，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：<code>错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号</code>。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 <code>Too simple</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">3 4 
3 4 2 a c
2 5 1 b
5 3 2 b c
1 5 4 a b d e
(2 a c) (3 b d e) (2 a c) (3 a b e)
(2 a c) (1 b) (2 a b) (4 a b d e)
(2 b d) (1 e) (1 c) (4 a b c d)
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">3.5
6.0
2.5
2 2-e
2 3-a
2 3-b
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">2 2 
3 4 2 a c
2 5 1 b
(2 a c) (1 b)
(2 a c) (1 b)
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">5.0
5.0
Too simple
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目是<code>1058 选择题</code>的升级版，不仅需要判断对错，还需要找出什么选项出现错误：</p>
<blockquote>
<p>先说明一下三种运算：异或、与、或</p>
<p>异或^运算：当两个数不同时取1，相同时取0</p>
<p>与&amp;运算：当两个数全1时取1，其余情况取0</p>
<p>或 | 运算：只有两个数全0时取0，其余情况取1</p>
<p>本题关于判断题目选项错误以及错误点便可以采取以上运算</p>
<p>先采用异或运算，通过是否全0判断错误，并标出错误选项</p>
<p>再通过与运算，通过和正确选项对比，判断是否存在多选的情况</p>
<p>然后通过或运算，判断错误选项分别是哪几个</p>
<p>举个栗子：选项答案为BC（01100），学生答案为AC（10100）</p>
<p>异或（11000）存在错误---&gt;与（00100）存在多选---&gt;或运算判断存在A（错选）B（漏选）错误</p>
<p>具体细节观察代码，自行推演计算</p>
</blockquote>
<p>存储变量的含义：</p>
<blockquote>
<p><code>fullscre</code>存储每个题目的分值；<code>trueopt</code>存储每个题目的选项和</p>
<p><code>cnt</code>存储每个题目的每个选项的错误次数；<code>opt</code>存储每个学生的每个题目的选项和</p>
</blockquote>
<p>整个题目的重难点主要在于判断哪些选项错误，其余的细节基本与<a href="https://dreammilk.now.sh/1058-xuan-ze-ti-20-fen/"><code>1058 选择题</code></a>类似</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
int main() {
    int n, m, optnum, truenum, temp, maxcnt = 0;
    int hash[] = {1, 2, 4, 8, 16}, opt[1010][110] = {0};
    char c;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    vector&lt;int&gt; fullscore(m), trueopt(m);
    vector&lt;vector&lt;int&gt;&gt; cnt(m, vector&lt;int&gt;(5));
    for (int i = 0; i &lt; m; i++) {
        scanf(&quot;%d %d %d&quot;, &amp;fullscore[i], &amp;optnum, &amp;truenum);
        for (int j = 0; j &lt; truenum; j++) {
            scanf(&quot; %c&quot;, &amp;c);
            trueopt[i] += hash[c-'a'];
        }
    }
    for (int i = 0; i &lt; n; i++) {
        double grade = 0;
        for (int j = 0; j &lt; m; j++) {
            getchar();
            scanf(&quot;(%d&quot;, &amp;temp);
            for (int k = 0; k &lt; temp; k++) {
                scanf(&quot; %c)&quot;, &amp;c);
                opt[i][j] += hash[c-'a'];
            }
            int el = opt[i][j] ^ trueopt[j];
            if (el) {
                if ((opt[i][j] | trueopt[j]) == trueopt[j]) {
                    grade += fullscore[j] * 1.0 / 2;
                }
                if (el) {
                    for (int k = 0; k &lt; 5; k++)
                        if (el &amp; hash[k]) cnt[j][k]++;
                }
            } else {
                grade += fullscore[j];
            }
        }
        printf(&quot;%.1f\n&quot;, grade);
    }
    for (int i = 0; i &lt; m; i++)
        for (int j = 0; j &lt; 5; j++)
            maxcnt = maxcnt &gt; cnt[i][j] ? maxcnt : cnt[i][j];

    if (maxcnt == 0) {
        printf(&quot;Too simple\n&quot;);
    } else {
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; cnt[i].size(); j++) {
                if (maxcnt == cnt[i][j])
                    printf(&quot;%d %d-%c\n&quot;, maxcnt, i+1, 'a'+j);
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>