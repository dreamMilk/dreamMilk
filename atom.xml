<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dreammilk.now.sh</id>
    <title>Milk &apos;s Home</title>
    <updated>2020-06-10T13:26:33.356Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dreammilk.now.sh"/>
    <link rel="self" href="https://dreammilk.now.sh/atom.xml"/>
    <subtitle>welcome</subtitle>
    <logo>https://dreammilk.now.sh/images/avatar.png</logo>
    <icon>https://dreammilk.now.sh/favicon.ico</icon>
    <rights>All rights reserved 2020, Milk &apos;s Home</rights>
    <entry>
        <title type="html"><![CDATA[1074 宇宙无敌加法器 (20分)]]></title>
        <id>https://dreammilk.now.sh/1074-yu-zhou-wu-di-jia-fa-qi-20-fen/</id>
        <link href="https://dreammilk.now.sh/1074-yu-zhou-wu-di-jia-fa-qi-20-fen/">
        </link>
        <updated>2020-06-10T04:44:56.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出两个 PAT 数之和。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">30527
06203
415
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">7201
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目没有什么比较绕的地方：</p>
<blockquote>
<p>先将数字都与进制位数对齐，不足的前面补零</p>
<p>然后像题干中的运算过程一样，统计当前位的数字以及是否进位</p>
<p>最后得出运算结果输出即可</p>
</blockquote>
<p>一些需要注意的地方：</p>
<blockquote>
<p>进制中的0是10，使用时需要稍微加工一下</p>
<p>对于首位相加进位，需要记得在结果前面添加<code>1</code>，（PS：两个数相加进位不可能是2）</p>
<p>结果为全零时，需要输出0</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;

int main() {
    string jz,n,m;
    cin &gt;&gt; jz &gt;&gt; n &gt;&gt; m;
    m.insert(0,jz.length()-m.length(),'0');
    n.insert(0,jz.length()-n.length(),'0');
    reverse(n.begin(),n.end());
    reverse(m.begin(),m.end());
    reverse(jz.begin(),jz.end());
    int up=0;string str;
    for(int i=0;i&lt;jz.length();i++){
        int j = jz[i]=='0'?10:jz[i]-'0';
        int num = (n[i]-'0'+m[i]-'0'+up)%j;
        up = (n[i]-'0'+m[i]-'0'+up)/j;
        str.insert(0,1,num+'0');
    }
    if(up!=0) str = '1'+str;
    bool flag = false;
    for(int i=0;i&lt;str.length();i++){
        if(str[i]!='0' || flag){
            flag = true;
            cout &lt;&lt; str[i];
        }
    }
    if(!flag) printf(&quot;0&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1073 多选题常见计分法 (20分)]]></title>
        <id>https://dreammilk.now.sh/1073-duo-xuan-ti-chang-jian-ji-fen-fa-20-fen/</id>
        <link href="https://dreammilk.now.sh/1073-duo-xuan-ti-chang-jian-ji-fen-fa-20-fen/">
        </link>
        <updated>2020-06-09T04:28:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 <code>(选中的选项个数 选项1 ……)</code>，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：<code>错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号</code>。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 <code>Too simple</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">3 4 
3 4 2 a c
2 5 1 b
5 3 2 b c
1 5 4 a b d e
(2 a c) (3 b d e) (2 a c) (3 a b e)
(2 a c) (1 b) (2 a b) (4 a b d e)
(2 b d) (1 e) (1 c) (4 a b c d)
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">3.5
6.0
2.5
2 2-e
2 3-a
2 3-b
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">2 2 
3 4 2 a c
2 5 1 b
(2 a c) (1 b)
(2 a c) (1 b)
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">5.0
5.0
Too simple
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目是<code>1058 选择题</code>的升级版，不仅需要判断对错，还需要找出什么选项出现错误：</p>
<blockquote>
<p>先说明一下三种运算：异或、与、或</p>
<p>异或^运算：当两个数不同时取1，相同时取0</p>
<p>与&amp;运算：当两个数全1时取1，其余情况取0</p>
<p>或 | 运算：只有两个数全0时取0，其余情况取1</p>
<p>本题关于判断题目选项错误以及错误点便可以采取以上运算</p>
<p>先采用异或运算，通过是否全0判断错误，并标出错误选项</p>
<p>再通过与运算，通过和正确选项对比，判断是否存在多选的情况</p>
<p>然后通过或运算，判断错误选项分别是哪几个</p>
<p>举个栗子：选项答案为BC（01100），学生答案为AC（10100）</p>
<p>异或（11000）存在错误---&gt;与（00100）存在多选---&gt;或运算判断存在A（错选）B（漏选）错误</p>
<p>具体细节观察代码，自行推演计算</p>
</blockquote>
<p>存储变量的含义：</p>
<blockquote>
<p><code>fullscre</code>存储每个题目的分值；<code>trueopt</code>存储每个题目的选项和</p>
<p><code>cnt</code>存储每个题目的每个选项的错误次数；<code>opt</code>存储每个学生的每个题目的选项和</p>
</blockquote>
<p>整个题目的重难点主要在于判断哪些选项错误，其余的细节基本与<a href="https://dreammilk.now.sh/1058-xuan-ze-ti-20-fen/"><code>1058 选择题</code></a>类似</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
int main() {
    int n, m, optnum, truenum, temp, maxcnt = 0;
    int hash[] = {1, 2, 4, 8, 16}, opt[1010][110] = {0};
    char c;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    vector&lt;int&gt; fullscore(m), trueopt(m);
    vector&lt;vector&lt;int&gt;&gt; cnt(m, vector&lt;int&gt;(5));
    for (int i = 0; i &lt; m; i++) {
        scanf(&quot;%d %d %d&quot;, &amp;fullscore[i], &amp;optnum, &amp;truenum);
        for (int j = 0; j &lt; truenum; j++) {
            scanf(&quot; %c&quot;, &amp;c);
            trueopt[i] += hash[c-'a'];
        }
    }
    for (int i = 0; i &lt; n; i++) {
        double grade = 0;
        for (int j = 0; j &lt; m; j++) {
            getchar();
            scanf(&quot;(%d&quot;, &amp;temp);
            for (int k = 0; k &lt; temp; k++) {
                scanf(&quot; %c)&quot;, &amp;c);
                opt[i][j] += hash[c-'a'];
            }
            int el = opt[i][j] ^ trueopt[j];
            if (el) {
                if ((opt[i][j] | trueopt[j]) == trueopt[j]) {
                    grade += fullscore[j] * 1.0 / 2;
                }
                if (el) {
                    for (int k = 0; k &lt; 5; k++)
                        if (el &amp; hash[k]) cnt[j][k]++;
                }
            } else {
                grade += fullscore[j];
            }
        }
        printf(&quot;%.1f\n&quot;, grade);
    }
    for (int i = 0; i &lt; m; i++)
        for (int j = 0; j &lt; 5; j++)
            maxcnt = maxcnt &gt; cnt[i][j] ? maxcnt : cnt[i][j];

    if (maxcnt == 0) {
        printf(&quot;Too simple\n&quot;);
    } else {
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; cnt[i].size(); j++) {
                if (maxcnt == cnt[i][j])
                    printf(&quot;%d %d-%c\n&quot;, maxcnt, i+1, 'a'+j);
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1072 开学寄语 (20分)]]></title>
        <id>https://dreammilk.now.sh/1072-kai-xue-ji-yu-20-fen/</id>
        <link href="https://dreammilk.now.sh/1072-kai-xue-ji-yu-20-fen/">
        </link>
        <updated>2020-06-08T03:44:57.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="jiyu.JPG" loading="lazy"></figure>
<p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="jiyu.JPG" loading="lazy"></figure>
<p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：</p>
<pre><code class="language-in">姓名缩写: 物品编号1 物品编号2 ……
</code></pre>
<p>最后一行输出存在问题的学生的总人数和被查缴物品的总数。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">4 2
2333 6666
CYLL 3 1234 2345 3456
U 4 9966 6666 8888 6666
GG 2 2333 7777
JJ 3 0012 6666 2333
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">U: 6666 6666
GG: 2333
JJ: 6666 2333
3 5
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>将输入的违禁品编号使用<code>bool ban[10000]</code>进行存储，不属于违禁品的默认false</p>
<p>循环遍历学生以及携带物品，使用flag判断学生是否携带违禁品，并利用stu统计违规学生，cnt统计违禁品数量</p>
<p>flag还可以控制是否输出过名字，保证输出格式规范</p>
</blockquote>
<p>对于违禁品编号的存储：</p>
<blockquote>
<p>一开始发现题目中说明违禁品数量不超过6个，于是决定选择使用map存储</p>
<p>但是运行的时候发现，使用map存储的耗时要比数组慢很多，但是空间使用却没有太大的区别</p>
</blockquote>
<p>数组与map相比，还是数组香，因此在相同情况下还是选择使用数组会比较好</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

int main() {
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    bool ban[10000]={false};
    for(int i=0;i&lt;m;i++){
        int id;
        scanf(&quot;%d&quot;,&amp;id);
        ban[id]=true;
    }
    int cnt=0,stu=0;
    for(int i=0;i&lt;n;i++){
        char name[10];
        int num;
        bool flag=true;
        scanf(&quot;%s %d&quot;,&amp;name,&amp;num);
        for(int j=0;j&lt;num;j++){
            int id;
            scanf(&quot;%d&quot;,&amp;id);
            if(ban[id] &amp;&amp; flag){
                printf(&quot;%s: %04d&quot;,name,id);
                cnt++;
                flag = false;
            }else if(ban[id]){
                printf(&quot; %04d&quot;,id);
                cnt++;
            }
        }
        if(!flag){
            stu++;
            printf(&quot;\n&quot;);
        }
    }
    printf(&quot;%d %d\n&quot;,stu,cnt);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1071 小赌怡情 (15分)]]></title>
        <id>https://dreammilk.now.sh/1071-xiao-du-yi-qing-15-fen/</id>
        <link href="https://dreammilk.now.sh/1071-xiao-du-yi-qing-15-fen/">
        </link>
        <updated>2020-06-07T04:10:57.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p>
<p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p>
<p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字：</p>
<pre><code class="language-in">n1 b t n2
</code></pre>
<p>其中 <code>n1</code> 和 <code>n2</code> 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。<code>b</code> 为 0 表示玩家赌<code>小</code>，为 1 表示玩家赌<code>大</code>。<code>t</code> 表示玩家下注的筹码数，保证在整型范围内。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对每一次游戏，根据下列情况对应输出（其中 <code>t</code> 是玩家下注量，<code>x</code> 是玩家当前持有的筹码量）：</p>
<ul>
<li>玩家赢，输出 <code>Win t! Total = x.</code>；</li>
<li>玩家输，输出 <code>Lose t. Total = x.</code>；</li>
<li>玩家下注超过持有的筹码量，输出 <code>Not enough tokens. Total = x.</code>；</li>
<li>玩家输光后，输出 <code>Game Over.</code> 并结束程序。</li>
</ul>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">100 4
8 0 100 2
3 1 50 1
5 1 200 6
7 0 200 8
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">Win 100!  Total = 200.
Lose 50.  Total = 150.
Not enough tokens.  Total = 150.
Not enough tokens.  Total = 150.
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">100 4
8 0 100 2
3 1 200 1
5 1 200 6
7 0 200 8
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">Win 100!  Total = 200.
Lose 200.  Total = 0.
Game Over.
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>每次先比较当前筹码与是否能够下注，如果能够下注继续判断输赢情况</p>
<p>如果本局输了之后筹码归零，则直接退出程序</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

int main() {
    int T,k;
    cin &gt;&gt; T &gt;&gt; k;
    for(int i=0;i&lt;k;i++){
        int n1,b,t,n2;
        scanf(&quot;%d %d %d %d&quot;,&amp;n1,&amp;b,&amp;t,&amp;n2);
        if(T &lt; t) printf(&quot;Not enough tokens.  Total = %d.\n&quot;,T);
        else{
            if((n1 &lt; n2&amp;&amp;b==1)  || (n1 &gt; n2&amp;&amp;b==0)){
                T += t;
                printf(&quot;Win %d!  Total = %d.\n&quot;,t,T);
            }
            else{
                T -= t;
                printf(&quot;Lose %d.  Total = %d.\n&quot;,t,T);
            }
            if(T == 0){
                printf(&quot;Game Over.&quot;);
                break;
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1070 结绳 (25分)]]></title>
        <id>https://dreammilk.now.sh/1070-jie-sheng-25-fen/</id>
        <link href="https://dreammilk.now.sh/1070-jie-sheng-25-fen/">
        </link>
        <updated>2020-06-06T04:31:25.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt="rope.jpg" loading="lazy"></figure>
<p>给定 <em>N</em> 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt="rope.jpg" loading="lazy"></figure>
<p>给定 <em>N</em> 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 <em>N</em> (2≤<em>N</em>≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)；第 2 行给出 <em>N</em> 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">8
10 15 12 3 4 13 1 15
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">14
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目求串成的绳子的最大长度：</p>
<blockquote>
<p>因为n个绳子变为一根绳子一定会经过n-1次结绳，为防止对折损失的长度最小，应从短绳开始进行结绳</p>
</blockquote>
<p>有了上面的想法就比较容易了：</p>
<blockquote>
<p>将输入的数字按从小到大的顺序进行排序，然后每次将两个绳子相加除二，最终所得长度即为最大长度</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

using namespace std;

int main() {
    int m;
    cin &gt;&gt; m;
    vector&lt;int&gt; v(m);
    for(int i=0;i&lt;m;i++){
        cin &gt;&gt; v[i];
    }
    sort(v.begin(),v.end());
    int length=v[0];
    for(int i=1;i&lt;m;i++){
        length = (length+v[i])/2;
    }
    cout &lt;&lt; length;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1069 微博转发抽奖 (20分)]]></title>
        <id>https://dreammilk.now.sh/1069-wei-bo-zhuan-fa-chou-jiang-20-fen/</id>
        <link href="https://dreammilk.now.sh/1069-wei-bo-zhuan-fa-chou-jiang-20-fen/">
        </link>
        <updated>2020-06-05T03:57:57.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。</p>
<p>注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 <code>Keep going...</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">9 3 2
Imgonnawin!
PickMe
PickMeMeMeee
LookHere
Imgonnawin!
TryAgainAgain
TryAgainAgain
Imgonnawin!
TryAgainAgain
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">PickMe
Imgonnawin!
TryAgainAgain
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">2 3 5
Imgonnawin!
PickMe
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">Keep going...
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>当总人数小于第一位中奖者号码时，说明无人中奖</p>
<p>使用<code>map</code>记录每个id的出现次数，避免重复参与抽奖</p>
<p>然后根据题目逻辑进行判断处理</p>
</blockquote>
<p>对于题目逻辑可能有点争议：</p>
<blockquote>
<p>对于是选择到中奖者后判断是否重复；还是每一个都要判断是否重复，然后顺取下一位</p>
<p>这两种写法都可以通过测试，应该是样例数据的问题，题目的意思应该为前者</p>
</blockquote>
<p>这个问题在写代码时浑然不知，复盘一遍还是能够发现代码的不足之处😁</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;map&gt;

using namespace std;

int main() {
    int m,n,s;
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; s;
    map&lt;string,int&gt; mp;
    if(m&lt;s) cout &lt;&lt; &quot;Keep going...&quot;;
    for(int i=1;i&lt;=m;i++){
        string id;
        cin &gt;&gt; id;
        if(i==s &amp;&amp; mp[id]==0){
            cout &lt;&lt; id &lt;&lt; endl;
            mp[id]++;
            s += n;
        }
        else if(i==s &amp;&amp; mp[id]!=0) s++;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1068 万绿丛中一点红 (20分)]]></title>
        <id>https://dreammilk.now.sh/1068-wan-lu-cong-zhong-yi-dian-hong-20-fen/</id>
        <link href="https://dreammilk.now.sh/1068-wan-lu-cong-zhong-yi-dian-hong-20-fen/">
        </link>
        <updated>2020-06-04T04:59:09.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 <em>M</em>×<em>N</em> 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 <em>M</em>×<em>N</em> 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出三个正整数，分别是 <em>M</em> 和 <em>N</em>（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 <em>N</em> 行，每行给出 <em>M</em> 个像素的颜色值，范围在 [0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup></mrow><annotation encoding="application/x-tex">2^{24}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>) 内。所有同行数字间用空格或 TAB 分开。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中按照 <code>(x, y): color</code> 的格式输出所求像素点的位置以及颜色值，其中位置 <code>x</code> 和 <code>y</code> 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 <code>Not Unique</code>；如果这样的点不存在，则输出 <code>Not Exist</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">8 6 200
0 	 0 	  0 	   0	    0 	     0 	      0        0
65280 	 65280    65280    16711479 65280    65280    65280    65280
16711479 65280    65280    65280    16711680 65280    65280    65280
65280 	 65280    65280    65280    65280    65280    165280   165280
65280 	 65280 	  16777015 65280    65280    165280   65480    165280
16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">(5, 3): 16711680
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">4 5 2
0 0 0 0
0 0 3 0
0 0 0 0
0 5 0 0
0 0 0 0
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">Not Unique
</code></pre>
<h3 id="输入样例3">输入样例3：</h3>
<pre><code class="language-in">3 3 5
1 2 3
3 4 5
5 6 7
</code></pre>
<h3 id="输出样例3">输出样例3：</h3>
<pre><code class="language-out">Not Exist
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目一开始例子没怎么看懂：</p>
<blockquote>
<p>一直在纠结<code>16711479</code>为什么不符合要求，原来首要条件是像素点颜色只能出现一次</p>
</blockquote>
<p>做题思路：</p>
<blockquote>
<p>因为需要统计颜色是否出现过一次，所以使用了<code>map</code>结构</p>
<p>可能会觉得这为什么不用数组结构了呢，因为题目输入的大部分数据重复率很高，不像随机散乱的数据</p>
<p>将输入的像素点用二维数组进行存储，并使用<code>map</code>统计出现次数</p>
<p>然后遍历二维数组，将只出现一次并与周围相差较大的像素点的行、列数保存，符合要求的个数加一</p>
<p>最后判断是否只存在一个要求，按照题意进行输出</p>
</blockquote>
<p>对于行列数不用担心覆盖的情况，如果覆盖说明不唯一，否则不会存在覆盖现象</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;map&gt;

using namespace std;

int m,n,tol;
vector&lt;vector&lt;int&gt;&gt; v;
int r[8][2]={{-1,-1},{0,-1},{1,-1},{-1,0},{1,0},{-1,1},{0,1},{1,1}};

bool round(int i,int j){
    for(int k=0;k&lt;8;k++){
        int x=i+r[k][0];
        int y=j+r[k][1];
        if(x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m&amp;&amp;v[i][j]-v[x][y]&gt;=0-tol&amp;&amp;v[i][j]-v[x][y]&lt;=tol) return false;
    }
    return true;

}

int main() {
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; tol;
    v.resize(n,vector&lt;int&gt;(m));
    map&lt;int,int&gt; M;
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;m;j++){
            cin &gt;&gt; v[i][j];
            M[v[i][j]]++;
        }
    }
    int cnt=0,x,y;
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;m;j++){
            if(M[v[i][j]]==1 &amp;&amp; round(i,j)){
                x = i+1;
                y = j+1;
                cnt++;
            }
        }
    }
    if(cnt==1) printf(&quot;(%d, %d): %d&quot;,y,x,v[x-1][y-1]);
    else if(cnt &gt; 1) printf(&quot;Not Unique&quot;);
    else printf(&quot;Not Exist&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1067 试密码 (20分)]]></title>
        <id>https://dreammilk.now.sh/1067-shi-mi-ma-20-fen/</id>
        <link href="https://dreammilk.now.sh/1067-shi-mi-ma-20-fen/">
        </link>
        <updated>2020-06-03T04:50:48.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 <code>Welcome in</code>，并结束程序；如果是错误的，则在一行中按格式输出 <code>Wrong password: 用户输入的错误密码</code>；当错误尝试达到 N 次时，再输出一行 <code>Account locked</code>，并结束程序。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">Correct%pw 3
correct%pw
Correct@PW
whatisthepassword!
Correct%pw
#
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">Wrong password: correct%pw
Wrong password: Correct@PW
Wrong password: whatisthepassword!
Account locked
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">cool@gplt 3
coolman@gplt
coollady@gplt
cool@gplt
try again
#
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">Wrong password: coolman@gplt
Wrong password: coollady@gplt
Welcome in
</code></pre>
<h3 id="思路">思路：</h3>
<p>感觉题目相对比较简单：</p>
<blockquote>
<p>循环输入的字符串，遇到<code>#</code>结束、超过错误次数结束或者输入正确后结束</p>
<p>关于字符串可以直接通过<code>==</code>比较，每次输入错误时，计数加一</p>
</blockquote>
<p>一个小坑记录：</p>
<blockquote>
<p>在使用<code>getline</code>函数时，需要注意前面是否存在回车符号，如果有，需要使用<code>getchar</code>函数吃掉回车</p>
<p>在网上百度了一下，发现<code>scanf(&quot;\n&quot;)</code>与<code>getchar</code>函数在消除回车时的效果并不一样</p>
<p><code>scanf(&quot;\n&quot;)</code>有时候消除回车时并不彻底，而<code>getchar</code>函数的表现更胜一筹</p>
</blockquote>
<p>哪天有时间可以总结一下这些细枝末节🤓</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

int main() {
    string psd,input;
    int n,cnt=0;
    cin &gt;&gt; psd &gt;&gt; n;
    getchar();
    getline(cin,input);
    while(input!=&quot;#&quot; &amp;&amp; cnt&lt;n){
        if(input != psd){
            cnt++;
            cout &lt;&lt; &quot;Wrong password: &quot; &lt;&lt; input &lt;&lt; endl;
        }else{
            cout &lt;&lt; &quot;Welcome in&quot;;
            break;
        }
        getline(cin,input);
    }
    if(cnt == n) cout &lt;&lt; &quot;Account locked&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1066 图像过滤 (15分)]]></title>
        <id>https://dreammilk.now.sh/1066-tu-xiang-guo-lu-15-fen/</id>
        <link href="https://dreammilk.now.sh/1066-tu-xiang-guo-lu-15-fen/">
        </link>
        <updated>2020-06-02T04:39:19.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出一幅图像的分辨率，即两个正整数 <em>M</em> 和 <em>N</em>（0&lt;<em>M</em>,<em>N</em>≤500），另外是待过滤的灰度值区间端点 <em>A</em> 和 <em>B</em>（0≤<em>A</em>&lt;<em>B</em>≤255）、以及指定的替换灰度值。随后 <em>M</em> 行，每行给出 <em>N</em> 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>输出按要求过滤后的图像。即输出 <em>M</em> 行，每行 <em>N</em> 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 <code>000</code>），其间以一个空格分隔。行首尾不得有多余空格。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">3 5 100 150 0
3 189 254 101 119
150 233 151 99 100
88 123 149 0 255
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">003 189 254 000 000
000 233 151 099 000
088 000 000 000 255
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>遍历二维数组，如果在过滤范围内，替换即可</p>
</blockquote>
<p>输出时使用<code>%03d</code>即可</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

int main() {
    int m,n,a,b,g;
    scanf(&quot;%d%d%d%d%d&quot;,&amp;m,&amp;n,&amp;a,&amp;b,&amp;g);
    for(int i=0;i&lt;m;i++){
        for(int j=0;j&lt;n;j++){
            int color;scanf(&quot;%d&quot;,&amp;color);
            if(color&lt;a||color&gt;b) printf(&quot;%03d&quot;,color);
            else printf(&quot;%03d&quot;,g);
            if(j!=n-1) printf(&quot; &quot;);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1065 单身狗 (25分)]]></title>
        <id>https://dreammilk.now.sh/1065-dan-shen-gou-25-fen/</id>
        <link href="https://dreammilk.now.sh/1065-dan-shen-gou-25-fen/">
        </link>
        <updated>2020-06-01T04:59:54.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">3
11111 22222
33333 44444
55555 66666
7
55555 44444 10000 88888 22222 11111 23333
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">5
10000 23333 44444 55555 88888
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目寻找单身🐶，包括当时没有伴侣的人：</p>
<blockquote>
<p>首先说明变量：id数组用于保存伴侣关系，其中id数组默认值为-1（没有伴侣）；</p>
<p>visitor数组用于保存参与者id；</p>
<p>iscome数组用于保存是否到场的信息，默认为0（未到场）；</p>
<p>single数组用于保存单身人士id；</p>
</blockquote>
<p>再过一下运行流程：</p>
<blockquote>
<p>先将每一对伴侣信息存入id中，然后将每一个参与者的id存储<code>visitor</code>中，并判断参与者是否有伴侣关系，如果存在伴侣关系，则将该参与者的伴侣在iscome数组中变为1</p>
<p>这一步是为存在伴侣关系并且到场的人进行标记；比如a和b是伴侣，a到场b未到场，则<code>iscome[b]=1</code>，<code>iscome[a]=0</code>；这意味着当事人的伴侣不在场的话，当事人在<code>iscome</code>数组中永远为0</p>
<p>再循环visitor数组，判断iscome数组中值是否为0，如果为0说明该参与者是单身人士</p>
</blockquote>
<p>注意事项：</p>
<blockquote>
<p>对于id数组的默认值不能设为0，因为id可以为0</p>
<p>输出时记得使用格式化输出<code>%05d</code></p>
</blockquote>
<p>关于<code>iscome</code>数组，只有你的伴侣在场时，你的伴侣会将她（他）的伴侣（也就是你）置为1，证明你是一个有伴侣的人</p>
<p>相当于她（他）到场后会喊一嗓子：我是你的女（男）朋友</p>
<p>因为这个逻辑有点烧脑，容易混乱，所以有点啰嗦，希望能够写的通俗易懂一点</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;set&gt;

using namespace std;

int main() {
    int n;
    cin &gt;&gt; n;
    int id[100000]={-1};
    for(int i=0;i&lt;n;i++){
        int man,femal;
        cin &gt;&gt; man &gt;&gt; femal;
        id[man] = femal;
        id[femal] = man;
    }
    int num;cin &gt;&gt; num;
    vector&lt;int&gt; visitor(num);
    int iscome[100000]={0};
    for(int i=0;i&lt;num;i++){
        cin &gt;&gt; visitor[i];
        if(id[visitor[i]]!=-1) iscome[id[visitor[i]]] = 1;
    }
    set&lt;int&gt; single;
    for(int i=0;i&lt;num;i++){
        if(!iscome[visitor[i]]) single.insert(visitor[i]);
    }
    cout &lt;&lt; single.size() &lt;&lt; endl;
    for(auto it=single.begin();it!=single.end();it++){
        if(it==single.begin()) printf(&quot;%05d&quot;,*it);
        else printf(&quot; %05d&quot;,*it);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>