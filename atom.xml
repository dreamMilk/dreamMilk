<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dreammilk.now.sh</id>
    <title>Milk &apos;s Home</title>
    <updated>2020-06-15T03:32:42.876Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dreammilk.now.sh"/>
    <link rel="self" href="https://dreammilk.now.sh/atom.xml"/>
    <subtitle>welcome</subtitle>
    <logo>https://dreammilk.now.sh/images/avatar.png</logo>
    <icon>https://dreammilk.now.sh/favicon.ico</icon>
    <rights>All rights reserved 2020, Milk &apos;s Home</rights>
    <entry>
        <title type="html"><![CDATA[1079 延迟的回文数 (20分)]]></title>
        <id>https://dreammilk.now.sh/1079-yan-chi-de-hui-wen-shu-20-fen/</id>
        <link href="https://dreammilk.now.sh/1079-yan-chi-de-hui-wen-shu-20-fen/">
        </link>
        <updated>2020-06-15T03:30:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个 <em>k</em>+1 位的正整数 <em>N</em>，写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>⋯<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_1a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的形式，其中对所有 <em>i</em> 有 0≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&lt;10 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&gt;0。<em>N</em> 被称为一个<strong>回文数</strong>，当且仅当对所有 <em>i</em> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>−<em>i</em>。零也被定义为一个回文数。</p>
<p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为<strong>延迟的回文数</strong>。（定义翻译自 https://en.wikipedia.org/wiki/Palindromic_number ）</p>
<p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个 <em>k</em>+1 位的正整数 <em>N</em>，写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>⋯<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_1a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的形式，其中对所有 <em>i</em> 有 0≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&lt;10 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&gt;0。<em>N</em> 被称为一个<strong>回文数</strong>，当且仅当对所有 <em>i</em> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>−<em>i</em>。零也被定义为一个回文数。</p>
<p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为<strong>延迟的回文数</strong>。（定义翻译自 https://en.wikipedia.org/wiki/Palindromic_number ）</p>
<p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在一行中给出一个不超过1000位的正整数。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对给定的整数，一行一行输出其变出回文数的过程。每行格式如下</p>
<pre><code class="language-markdown">A + B = C
</code></pre>
<p>其中 <code>A</code> 是原始的数字，<code>B</code> 是 <code>A</code> 的逆转数，<code>C</code> 是它们的和。<code>A</code> 从输入的整数开始。重复操作直到 <code>C</code> 在 10 步以内变成回文数，这时在一行中输出 <code>C is a palindromic number.</code>；或者如果 10 步都没能得到回文数，最后就在一行中输出 <code>Not found in 10 iterations.</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">97152
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">97152 + 25179 = 122331
122331 + 133221 = 255552
255552 is a palindromic number.
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">196
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">196 + 691 = 887
887 + 788 = 1675
1675 + 5761 = 7436
7436 + 6347 = 13783
13783 + 38731 = 52514
52514 + 41525 = 94039
94039 + 93049 = 187088
187088 + 880781 = 1067869
1067869 + 9687601 = 10755470
10755470 + 07455701 = 18211171
Not found in 10 iterations.
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目隐藏的意思：</p>
<blockquote>
<p>如果输入的数字就是回文数的话，直接输出<code>C is a palindromic number.</code></p>
</blockquote>
<p>大致过程：</p>
<blockquote>
<p>进行10次循环，每次先对输入字符串判断是否为回文数，如果是则退出，否则下一步</p>
<p>然后输出等式并将字符串与反转字符串相加，得到新的字符串</p>
<p>结束循环后判断是否是中途退出循环，如果是则符合回文要求，否则不能得到回文数</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    string input,str;
    cin &gt;&gt; str;
    int i;
    for(i=0;i&lt;10;i++){
        input = str;
        reverse(str.begin(),str.end());
        if(input == str){
            cout &lt;&lt; input &lt;&lt; &quot; is a palindromic number.&quot;;
            break;
        }
        cout &lt;&lt; input &lt;&lt; &quot; + &quot;;

        cout &lt;&lt; str &lt;&lt; &quot; = &quot;;
        int up=0;str=&quot;&quot;;
        for(int j=0;j&lt;input.length();j++){
            char c;
            int num=input[j]+input[input.length()-1-j]-2*'0'+up;
            c = num%10+'0';
            up = num/10;
            str = c+str;
        }
        if(up!=0) str = &quot;1&quot;+str;
        cout &lt;&lt; str &lt;&lt; endl;
    }
    if(i==10) cout &lt;&lt; &quot;Not found in 10 iterations.&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1078 字符串压缩与解压 (20分)]]></title>
        <id>https://dreammilk.now.sh/1078-zi-fu-chuan-ya-suo-yu-jie-ya-20-fen/</id>
        <link href="https://dreammilk.now.sh/1078-zi-fu-chuan-ya-suo-yu-jie-ya-20-fen/">
        </link>
        <updated>2020-06-14T04:25:53.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 <code>ccccc</code> 就用 <code>5c</code> 来表示。如果字符没有重复，就原样输出。例如 <code>aba</code> 压缩后仍然是 <code>aba</code>。</p>
<p>解压方法就是反过来，把形如 <code>5c</code> 这样的表示恢复为 <code>ccccc</code>。</p>
<p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 <code>ccccc</code> 就用 <code>5c</code> 来表示。如果字符没有重复，就原样输出。例如 <code>aba</code> 压缩后仍然是 <code>aba</code>。</p>
<p>解压方法就是反过来，把形如 <code>5c</code> 这样的表示恢复为 <code>ccccc</code>。</p>
<p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个字符，如果是 <code>C</code> 就表示下面的字符串需要被压缩；如果是 <code>D</code> 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>根据要求压缩或解压字符串，并在一行中输出结果。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">C
TTTTThhiiiis isssss a   tesssst CAaaa as
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">5T2h4is i5s a3 te4st CA3a as
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">D
5T2h4is i5s a3 te4st CA3a as10Z
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">TTTTThhiiiis isssss a   tesssst CAaaa asZZZZZZZZZZ
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>在压缩字符串时存在两个变量，<code>temp</code>和<code>cnt</code>分别是前一个字母与出现次数</p>
<p>如果当前字母与<code>temp</code>不同，则输出<code>cnt</code>和<code>temp</code>，如果<code>cnt</code>为1则省略；不同时<code>cnt++</code></p>
<p>在解压字符串时需要注意连续出现数字的情况，这些数字需要变为一个整体</p>
<p>然后每次输出时循环打印即可</p>
</blockquote>
<p>需要注意输入输出的格式问题，避免存储错误信息</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cctype&gt;

using namespace std;

int main() {
    char c;
    string s;
    int cnt=0;
    cin &gt;&gt; c;
    getchar();
    getline(cin,s);
    if(c=='C'){
        char temp = s[0];
        for(int i=1;i&lt;s.length();i++){
            if(s[i]==temp) cnt++;
            else{
                if(cnt==0) cout &lt;&lt; temp;
                else cout &lt;&lt; cnt+1 &lt;&lt; temp;
                temp = s[i];
                cnt = 0;
            }
        }
        if(cnt==0) cout &lt;&lt; temp;
        else cout &lt;&lt; cnt+1 &lt;&lt; temp;
    }
    else{
        for(int i=0;i&lt;s.length();i++){
            if(isdigit(s[i])) cnt = cnt*10 + s[i]-'0';
            else{
                cnt = cnt==0?1:cnt;
                for(int j=0;j&lt;cnt;j++) cout &lt;&lt; s[i];
                cnt = 0;
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1077 互评成绩计算 (20分)]]></title>
        <id>https://dreammilk.now.sh/1077-hu-ping-cheng-ji-ji-suan-20-fen/</id>
        <link href="https://dreammilk.now.sh/1077-hu-ping-cheng-ji-ji-suan-20-fen/">
        </link>
        <updated>2020-06-13T04:49:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 <em>G</em>1；老师给这个组的评分记为 <em>G</em>2。该组得分为 (<em>G</em>1+<em>G</em>2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 <em>G</em>1；老师给这个组的评分记为 <em>G</em>2。该组得分为 (<em>G</em>1+<em>G</em>2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出两个正整数 <em>N</em>（&gt; 3）和 <em>M</em>，分别是分组数和满分，均不超过 100。随后 <em>N</em> 行，每行给出该组得到的 <em>N</em> 个分数（均保证为整型范围内的整数），其中第 1 个是老师给出的评分，后面 <em>N</em>−1 个是其他组给的评分。合法的输入应该是 [0,<em>M</em>] 区间内的整数，若不在合法区间内，则该分数须被忽略。题目保证老师的评分都是合法的，并且每个组至少会有 3 个来自同学的合法评分。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>为每个组输出其最终得分。每个得分占一行。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">6 50
42 49 49 35 38 41
36 51 50 28 -1 30
40 36 41 33 47 49
30 250 -25 27 45 31
48 0 0 50 50 1234
43 41 36 29 42 29
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">42
33
41
31
37
39
</code></pre>
<h3 id="思路">思路：</h3>
<p>唯一需要注意的是计算逻辑，需要看清楚题意：</p>
<blockquote>
<p>对输入的每行数据进行处理，寻找最大最小值，学生有效分数和数量总计，老师分数</p>
<p>计算时可以使用0.5来帮助小数进行四舍五入</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;n;i++){
        int teacher,cnt=0,MAX=0,MIN=m;
        float students=0;
        cin &gt;&gt; teacher;
        for(int j=0;j&lt;n-1;j++){
            int score;
            cin &gt;&gt; score;
            if(score&gt;=0&amp;&amp;score&lt;=m){
                if(score &gt; MAX) MAX = score;
                if(score &lt; MIN) MIN = score;
                students += score;
                cnt++;
            }
        }
        int sum=(teacher+(students-MAX-MIN)/(cnt-2))/2+0.5;
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1076 Wifi密码 (15分)]]></title>
        <id>https://dreammilk.now.sh/1076-wifi-mi-ma-15-fen/</id>
        <link href="https://dreammilk.now.sh/1076-wifi-mi-ma-15-fen/">
        </link>
        <updated>2020-06-12T04:52:45.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
</blockquote>
<!-- more -->
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/7e56be3f-caba-45f1-b9cb-38a96d44de76.jpg" alt="wifi.jpg" loading="lazy"></figure>
</blockquote>
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 <code>编号-答案</code> 的格式给出一道题的 4 个选项，<code>T</code> 表示正确选项，<code>F</code> 表示错误选项。选项间用空格分隔。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出 wifi 密码。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">8
A-T B-F C-F D-F
C-T B-F A-F D-F
A-F D-F C-F B-T
B-T A-F C-F D-F
B-F D-T A-F C-F
A-T C-F B-F D-F
D-T B-F C-F A-F
C-T A-F B-F D-F
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">13224143
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较简单：</p>
<blockquote>
<p>将每一行的输入读入时，判断正确选项并输出对应数字</p>
</blockquote>
<p>稍微注意一下输入：</p>
<blockquote>
<p>每行的回车符号与空格需要吃掉，避免错误读入</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;\n&quot;);
        bool flag=false;
        for(int j=0;j&lt;4;j++){
            char opt,ans;
            if(!flag){
                scanf(&quot;%c-%c&quot;,&amp;opt,&amp;ans);
                flag = true;
            }
            else scanf(&quot; %c-%c&quot;,&amp;opt,&amp;ans);
            if(ans == 'T') printf(&quot;%d&quot;,opt-'A'+1);
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1075 链表元素分类 (25分)]]></title>
        <id>https://dreammilk.now.sh/1075-lian-biao-yuan-su-fen-lei-25-fen/</id>
        <link href="https://dreammilk.now.sh/1075-lian-biao-yuan-su-fen-lei-25-fen/">
        </link>
        <updated>2020-06-11T03:59:35.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>)；以及正整数K (≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>
<p>接下来有 N 行，每行格式为：</p>
<pre><code class="language-in">Address Data Next
</code></pre>
<p>其中 <code>Address</code> 是结点地址；<code>Data</code> 是该结点保存的数据，为 [<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">−10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>] 区间内的整数；<code>Next</code> 是下一结点的地址。题目保证给出的链表不为空。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">00100 9 10
23333 10 27777
00000 0 99999
00100 18 12309
68237 -6 23333
33218 -4 00000
48652 -2 -1
99999 5 68237
27777 11 48652
12309 7 33218
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">33218 -4 68237
68237 -6 48652
48652 -2 12309
12309 7 00000
00000 0 99999
99999 5 23333
23333 10 00100
00100 18 27777
27777 11 -1
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目依旧是按照数组结构的顺序存储：</p>
<blockquote>
<p>构造一个表示结点的结构体，存储数据和下一个结点地址，然后使用数组存放</p>
<p>总共三次循环：第一次存储输入数据；第二次将数据按照大小分类；第三次将每个类中的数据输出</p>
<p>题目的意思是将数据分为（-∞，0）、[0，K]和（K，+∞），保持输入顺序即可</p>
</blockquote>
<p>其实最关键的地方在于输出的处理：</p>
<blockquote>
<p>往常一直是非常死板的认为输出语句最多输出一行的数据，可以保持输出代码比较整洁易读</p>
<p>本题的输出却是输出两行的内容，在输出当前节点时，不需要输出后续节点地址，而是有下一个结点负责补充</p>
<p>这样可以避免产生多余的控制逻辑，提高执行效率</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

struct Node{
    int data,next;
};

int main() {
    int start,n,k;
    Node sqlist[100000];
    scanf(&quot;%d %d %d&quot;,&amp;start,&amp;n,&amp;k);
    for(int i=0;i&lt;n;i++){
        int address;
        scanf(&quot;%d &quot;,&amp;address);
        scanf(&quot;%d %d&quot;,&amp;sqlist[address].data,&amp;sqlist[address].next);
    }
    int p=start;
    vector&lt;int&gt; v[3];
    while(p!=-1){
        if(sqlist[p].data &lt; 0) v[0].push_back(p);
        else if(sqlist[p].data &gt; k) v[2].push_back(p);
        else v[1].push_back(p);
        p = sqlist[p].next;
    }
    bool flag=false;
    for(int i=0;i&lt;3;i++){
        for(int j=0;j&lt;v[i].size();j++){
            if(flag){
                printf(&quot; %05d\n%05d %d&quot;,v[i][j],v[i][j],sqlist[v[i][j]].data);
            }
            else{
                printf(&quot;%05d %d&quot;,v[i][j],sqlist[v[i][j]].data);
                flag = true;
            }
        }
    }
    printf(&quot; -1&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1074 宇宙无敌加法器 (20分)]]></title>
        <id>https://dreammilk.now.sh/1074-yu-zhou-wu-di-jia-fa-qi-20-fen/</id>
        <link href="https://dreammilk.now.sh/1074-yu-zhou-wu-di-jia-fa-qi-20-fen/">
        </link>
        <updated>2020-06-10T04:44:56.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出两个 PAT 数之和。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">30527
06203
415
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">7201
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目没有什么比较绕的地方：</p>
<blockquote>
<p>先将数字都与进制位数对齐，不足的前面补零</p>
<p>然后像题干中的运算过程一样，统计当前位的数字以及是否进位</p>
<p>最后得出运算结果输出即可</p>
</blockquote>
<p>一些需要注意的地方：</p>
<blockquote>
<p>进制中的0是10，使用时需要稍微加工一下</p>
<p>对于首位相加进位，需要记得在结果前面添加<code>1</code>，（PS：两个数相加进位不可能是2）</p>
<p>结果为全零时，需要输出0</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;

int main() {
    string jz,n,m;
    cin &gt;&gt; jz &gt;&gt; n &gt;&gt; m;
    m.insert(0,jz.length()-m.length(),'0');
    n.insert(0,jz.length()-n.length(),'0');
    reverse(n.begin(),n.end());
    reverse(m.begin(),m.end());
    reverse(jz.begin(),jz.end());
    int up=0;string str;
    for(int i=0;i&lt;jz.length();i++){
        int j = jz[i]=='0'?10:jz[i]-'0';
        int num = (n[i]-'0'+m[i]-'0'+up)%j;
        up = (n[i]-'0'+m[i]-'0'+up)/j;
        str.insert(0,1,num+'0');
    }
    if(up!=0) str = '1'+str;
    bool flag = false;
    for(int i=0;i&lt;str.length();i++){
        if(str[i]!='0' || flag){
            flag = true;
            cout &lt;&lt; str[i];
        }
    }
    if(!flag) printf(&quot;0&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1073 多选题常见计分法 (20分)]]></title>
        <id>https://dreammilk.now.sh/1073-duo-xuan-ti-chang-jian-ji-fen-fa-20-fen/</id>
        <link href="https://dreammilk.now.sh/1073-duo-xuan-ti-chang-jian-ji-fen-fa-20-fen/">
        </link>
        <updated>2020-06-09T04:28:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 <code>(选中的选项个数 选项1 ……)</code>，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：<code>错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号</code>。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 <code>Too simple</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">3 4 
3 4 2 a c
2 5 1 b
5 3 2 b c
1 5 4 a b d e
(2 a c) (3 b d e) (2 a c) (3 a b e)
(2 a c) (1 b) (2 a b) (4 a b d e)
(2 b d) (1 e) (1 c) (4 a b c d)
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">3.5
6.0
2.5
2 2-e
2 3-a
2 3-b
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">2 2 
3 4 2 a c
2 5 1 b
(2 a c) (1 b)
(2 a c) (1 b)
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">5.0
5.0
Too simple
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目是<code>1058 选择题</code>的升级版，不仅需要判断对错，还需要找出什么选项出现错误：</p>
<blockquote>
<p>先说明一下三种运算：异或、与、或</p>
<p>异或^运算：当两个数不同时取1，相同时取0</p>
<p>与&amp;运算：当两个数全1时取1，其余情况取0</p>
<p>或 | 运算：只有两个数全0时取0，其余情况取1</p>
<p>本题关于判断题目选项错误以及错误点便可以采取以上运算</p>
<p>先采用异或运算，通过是否全0判断错误，并标出错误选项</p>
<p>再通过与运算，通过和正确选项对比，判断是否存在多选的情况</p>
<p>然后通过或运算，判断错误选项分别是哪几个</p>
<p>举个栗子：选项答案为BC（01100），学生答案为AC（10100）</p>
<p>异或（11000）存在错误---&gt;与（00100）存在多选---&gt;或运算判断存在A（错选）B（漏选）错误</p>
<p>具体细节观察代码，自行推演计算</p>
</blockquote>
<p>存储变量的含义：</p>
<blockquote>
<p><code>fullscre</code>存储每个题目的分值；<code>trueopt</code>存储每个题目的选项和</p>
<p><code>cnt</code>存储每个题目的每个选项的错误次数；<code>opt</code>存储每个学生的每个题目的选项和</p>
</blockquote>
<p>整个题目的重难点主要在于判断哪些选项错误，其余的细节基本与<a href="https://dreammilk.now.sh/1058-xuan-ze-ti-20-fen/"><code>1058 选择题</code></a>类似</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
int main() {
    int n, m, optnum, truenum, temp, maxcnt = 0;
    int hash[] = {1, 2, 4, 8, 16}, opt[1010][110] = {0};
    char c;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    vector&lt;int&gt; fullscore(m), trueopt(m);
    vector&lt;vector&lt;int&gt;&gt; cnt(m, vector&lt;int&gt;(5));
    for (int i = 0; i &lt; m; i++) {
        scanf(&quot;%d %d %d&quot;, &amp;fullscore[i], &amp;optnum, &amp;truenum);
        for (int j = 0; j &lt; truenum; j++) {
            scanf(&quot; %c&quot;, &amp;c);
            trueopt[i] += hash[c-'a'];
        }
    }
    for (int i = 0; i &lt; n; i++) {
        double grade = 0;
        for (int j = 0; j &lt; m; j++) {
            getchar();
            scanf(&quot;(%d&quot;, &amp;temp);
            for (int k = 0; k &lt; temp; k++) {
                scanf(&quot; %c)&quot;, &amp;c);
                opt[i][j] += hash[c-'a'];
            }
            int el = opt[i][j] ^ trueopt[j];
            if (el) {
                if ((opt[i][j] | trueopt[j]) == trueopt[j]) {
                    grade += fullscore[j] * 1.0 / 2;
                }
                if (el) {
                    for (int k = 0; k &lt; 5; k++)
                        if (el &amp; hash[k]) cnt[j][k]++;
                }
            } else {
                grade += fullscore[j];
            }
        }
        printf(&quot;%.1f\n&quot;, grade);
    }
    for (int i = 0; i &lt; m; i++)
        for (int j = 0; j &lt; 5; j++)
            maxcnt = maxcnt &gt; cnt[i][j] ? maxcnt : cnt[i][j];

    if (maxcnt == 0) {
        printf(&quot;Too simple\n&quot;);
    } else {
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; cnt[i].size(); j++) {
                if (maxcnt == cnt[i][j])
                    printf(&quot;%d %d-%c\n&quot;, maxcnt, i+1, 'a'+j);
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1072 开学寄语 (20分)]]></title>
        <id>https://dreammilk.now.sh/1072-kai-xue-ji-yu-20-fen/</id>
        <link href="https://dreammilk.now.sh/1072-kai-xue-ji-yu-20-fen/">
        </link>
        <updated>2020-06-08T03:44:57.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="jiyu.JPG" loading="lazy"></figure>
<p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="jiyu.JPG" loading="lazy"></figure>
<p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：</p>
<pre><code class="language-in">姓名缩写: 物品编号1 物品编号2 ……
</code></pre>
<p>最后一行输出存在问题的学生的总人数和被查缴物品的总数。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">4 2
2333 6666
CYLL 3 1234 2345 3456
U 4 9966 6666 8888 6666
GG 2 2333 7777
JJ 3 0012 6666 2333
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">U: 6666 6666
GG: 2333
JJ: 6666 2333
3 5
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>将输入的违禁品编号使用<code>bool ban[10000]</code>进行存储，不属于违禁品的默认false</p>
<p>循环遍历学生以及携带物品，使用flag判断学生是否携带违禁品，并利用stu统计违规学生，cnt统计违禁品数量</p>
<p>flag还可以控制是否输出过名字，保证输出格式规范</p>
</blockquote>
<p>对于违禁品编号的存储：</p>
<blockquote>
<p>一开始发现题目中说明违禁品数量不超过6个，于是决定选择使用map存储</p>
<p>但是运行的时候发现，使用map存储的耗时要比数组慢很多，但是空间使用却没有太大的区别</p>
</blockquote>
<p>数组与map相比，还是数组香，因此在相同情况下还是选择使用数组会比较好</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

int main() {
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    bool ban[10000]={false};
    for(int i=0;i&lt;m;i++){
        int id;
        scanf(&quot;%d&quot;,&amp;id);
        ban[id]=true;
    }
    int cnt=0,stu=0;
    for(int i=0;i&lt;n;i++){
        char name[10];
        int num;
        bool flag=true;
        scanf(&quot;%s %d&quot;,&amp;name,&amp;num);
        for(int j=0;j&lt;num;j++){
            int id;
            scanf(&quot;%d&quot;,&amp;id);
            if(ban[id] &amp;&amp; flag){
                printf(&quot;%s: %04d&quot;,name,id);
                cnt++;
                flag = false;
            }else if(ban[id]){
                printf(&quot; %04d&quot;,id);
                cnt++;
            }
        }
        if(!flag){
            stu++;
            printf(&quot;\n&quot;);
        }
    }
    printf(&quot;%d %d\n&quot;,stu,cnt);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1071 小赌怡情 (15分)]]></title>
        <id>https://dreammilk.now.sh/1071-xiao-du-yi-qing-15-fen/</id>
        <link href="https://dreammilk.now.sh/1071-xiao-du-yi-qing-15-fen/">
        </link>
        <updated>2020-06-07T04:10:57.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p>
<p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p>
<p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字：</p>
<pre><code class="language-in">n1 b t n2
</code></pre>
<p>其中 <code>n1</code> 和 <code>n2</code> 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。<code>b</code> 为 0 表示玩家赌<code>小</code>，为 1 表示玩家赌<code>大</code>。<code>t</code> 表示玩家下注的筹码数，保证在整型范围内。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对每一次游戏，根据下列情况对应输出（其中 <code>t</code> 是玩家下注量，<code>x</code> 是玩家当前持有的筹码量）：</p>
<ul>
<li>玩家赢，输出 <code>Win t! Total = x.</code>；</li>
<li>玩家输，输出 <code>Lose t. Total = x.</code>；</li>
<li>玩家下注超过持有的筹码量，输出 <code>Not enough tokens. Total = x.</code>；</li>
<li>玩家输光后，输出 <code>Game Over.</code> 并结束程序。</li>
</ul>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">100 4
8 0 100 2
3 1 50 1
5 1 200 6
7 0 200 8
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">Win 100!  Total = 200.
Lose 50.  Total = 150.
Not enough tokens.  Total = 150.
Not enough tokens.  Total = 150.
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">100 4
8 0 100 2
3 1 200 1
5 1 200 6
7 0 200 8
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">Win 100!  Total = 200.
Lose 200.  Total = 0.
Game Over.
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>每次先比较当前筹码与是否能够下注，如果能够下注继续判断输赢情况</p>
<p>如果本局输了之后筹码归零，则直接退出程序</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

int main() {
    int T,k;
    cin &gt;&gt; T &gt;&gt; k;
    for(int i=0;i&lt;k;i++){
        int n1,b,t,n2;
        scanf(&quot;%d %d %d %d&quot;,&amp;n1,&amp;b,&amp;t,&amp;n2);
        if(T &lt; t) printf(&quot;Not enough tokens.  Total = %d.\n&quot;,T);
        else{
            if((n1 &lt; n2&amp;&amp;b==1)  || (n1 &gt; n2&amp;&amp;b==0)){
                T += t;
                printf(&quot;Win %d!  Total = %d.\n&quot;,t,T);
            }
            else{
                T -= t;
                printf(&quot;Lose %d.  Total = %d.\n&quot;,t,T);
            }
            if(T == 0){
                printf(&quot;Game Over.&quot;);
                break;
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1070 结绳 (25分)]]></title>
        <id>https://dreammilk.now.sh/1070-jie-sheng-25-fen/</id>
        <link href="https://dreammilk.now.sh/1070-jie-sheng-25-fen/">
        </link>
        <updated>2020-06-06T04:31:25.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt="rope.jpg" loading="lazy"></figure>
<p>给定 <em>N</em> 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt="rope.jpg" loading="lazy"></figure>
<p>给定 <em>N</em> 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 <em>N</em> (2≤<em>N</em>≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)；第 2 行给出 <em>N</em> 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">8
10 15 12 3 4 13 1 15
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">14
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目求串成的绳子的最大长度：</p>
<blockquote>
<p>因为n个绳子变为一根绳子一定会经过n-1次结绳，为防止对折损失的长度最小，应从短绳开始进行结绳</p>
</blockquote>
<p>有了上面的想法就比较容易了：</p>
<blockquote>
<p>将输入的数字按从小到大的顺序进行排序，然后每次将两个绳子相加除二，最终所得长度即为最大长度</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

using namespace std;

int main() {
    int m;
    cin &gt;&gt; m;
    vector&lt;int&gt; v(m);
    for(int i=0;i&lt;m;i++){
        cin &gt;&gt; v[i];
    }
    sort(v.begin(),v.end());
    int length=v[0];
    for(int i=1;i&lt;m;i++){
        length = (length+v[i])/2;
    }
    cout &lt;&lt; length;
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>