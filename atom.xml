<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dreammilk.now.sh</id>
    <title>Milk &apos;s Home</title>
    <updated>2020-06-13T13:58:35.418Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dreammilk.now.sh"/>
    <link rel="self" href="https://dreammilk.now.sh/atom.xml"/>
    <subtitle>welcome</subtitle>
    <logo>https://dreammilk.now.sh/images/avatar.png</logo>
    <icon>https://dreammilk.now.sh/favicon.ico</icon>
    <rights>All rights reserved 2020, Milk &apos;s Home</rights>
    <entry>
        <title type="html"><![CDATA[1077 互评成绩计算 (20分)]]></title>
        <id>https://dreammilk.now.sh/1077-hu-ping-cheng-ji-ji-suan-20-fen/</id>
        <link href="https://dreammilk.now.sh/1077-hu-ping-cheng-ji-ji-suan-20-fen/">
        </link>
        <updated>2020-06-13T04:49:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 <em>G</em>1；老师给这个组的评分记为 <em>G</em>2。该组得分为 (<em>G</em>1+<em>G</em>2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 <em>G</em>1；老师给这个组的评分记为 <em>G</em>2。该组得分为 (<em>G</em>1+<em>G</em>2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出两个正整数 <em>N</em>（&gt; 3）和 <em>M</em>，分别是分组数和满分，均不超过 100。随后 <em>N</em> 行，每行给出该组得到的 <em>N</em> 个分数（均保证为整型范围内的整数），其中第 1 个是老师给出的评分，后面 <em>N</em>−1 个是其他组给的评分。合法的输入应该是 [0,<em>M</em>] 区间内的整数，若不在合法区间内，则该分数须被忽略。题目保证老师的评分都是合法的，并且每个组至少会有 3 个来自同学的合法评分。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>为每个组输出其最终得分。每个得分占一行。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">6 50
42 49 49 35 38 41
36 51 50 28 -1 30
40 36 41 33 47 49
30 250 -25 27 45 31
48 0 0 50 50 1234
43 41 36 29 42 29
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">42
33
41
31
37
39
</code></pre>
<h3 id="思路">思路：</h3>
<p>唯一需要注意的是计算逻辑，需要看清楚题意：</p>
<blockquote>
<p>对输入的每行数据进行处理，寻找最大最小值，学生有效分数和数量总计，老师分数</p>
<p>计算时可以使用0.5来帮助小数进行四舍五入</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;n;i++){
        int teacher,cnt=0,MAX=0,MIN=m;
        float students=0;
        cin &gt;&gt; teacher;
        for(int j=0;j&lt;n-1;j++){
            int score;
            cin &gt;&gt; score;
            if(score&gt;=0&amp;&amp;score&lt;=m){
                if(score &gt; MAX) MAX = score;
                if(score &lt; MIN) MIN = score;
                students += score;
                cnt++;
            }
        }
        int sum=(teacher+(students-MAX-MIN)/(cnt-2))/2+0.5;
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1076 Wifi密码 (15分)]]></title>
        <id>https://dreammilk.now.sh/1076-wifi-mi-ma-15-fen/</id>
        <link href="https://dreammilk.now.sh/1076-wifi-mi-ma-15-fen/">
        </link>
        <updated>2020-06-12T04:52:45.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
</blockquote>
<!-- more -->
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/7e56be3f-caba-45f1-b9cb-38a96d44de76.jpg" alt="wifi.jpg" loading="lazy"></figure>
</blockquote>
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 <code>编号-答案</code> 的格式给出一道题的 4 个选项，<code>T</code> 表示正确选项，<code>F</code> 表示错误选项。选项间用空格分隔。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出 wifi 密码。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">8
A-T B-F C-F D-F
C-T B-F A-F D-F
A-F D-F C-F B-T
B-T A-F C-F D-F
B-F D-T A-F C-F
A-T C-F B-F D-F
D-T B-F C-F A-F
C-T A-F B-F D-F
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">13224143
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较简单：</p>
<blockquote>
<p>将每一行的输入读入时，判断正确选项并输出对应数字</p>
</blockquote>
<p>稍微注意一下输入：</p>
<blockquote>
<p>每行的回车符号与空格需要吃掉，避免错误读入</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;\n&quot;);
        bool flag=false;
        for(int j=0;j&lt;4;j++){
            char opt,ans;
            if(!flag){
                scanf(&quot;%c-%c&quot;,&amp;opt,&amp;ans);
                flag = true;
            }
            else scanf(&quot; %c-%c&quot;,&amp;opt,&amp;ans);
            if(ans == 'T') printf(&quot;%d&quot;,opt-'A'+1);
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1075 链表元素分类 (25分)]]></title>
        <id>https://dreammilk.now.sh/1075-lian-biao-yuan-su-fen-lei-25-fen/</id>
        <link href="https://dreammilk.now.sh/1075-lian-biao-yuan-su-fen-lei-25-fen/">
        </link>
        <updated>2020-06-11T03:59:35.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>)；以及正整数K (≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>
<p>接下来有 N 行，每行格式为：</p>
<pre><code class="language-in">Address Data Next
</code></pre>
<p>其中 <code>Address</code> 是结点地址；<code>Data</code> 是该结点保存的数据，为 [<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">−10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>] 区间内的整数；<code>Next</code> 是下一结点的地址。题目保证给出的链表不为空。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">00100 9 10
23333 10 27777
00000 0 99999
00100 18 12309
68237 -6 23333
33218 -4 00000
48652 -2 -1
99999 5 68237
27777 11 48652
12309 7 33218
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">33218 -4 68237
68237 -6 48652
48652 -2 12309
12309 7 00000
00000 0 99999
99999 5 23333
23333 10 00100
00100 18 27777
27777 11 -1
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目依旧是按照数组结构的顺序存储：</p>
<blockquote>
<p>构造一个表示结点的结构体，存储数据和下一个结点地址，然后使用数组存放</p>
<p>总共三次循环：第一次存储输入数据；第二次将数据按照大小分类；第三次将每个类中的数据输出</p>
<p>题目的意思是将数据分为（-∞，0）、[0，K]和（K，+∞），保持输入顺序即可</p>
</blockquote>
<p>其实最关键的地方在于输出的处理：</p>
<blockquote>
<p>往常一直是非常死板的认为输出语句最多输出一行的数据，可以保持输出代码比较整洁易读</p>
<p>本题的输出却是输出两行的内容，在输出当前节点时，不需要输出后续节点地址，而是有下一个结点负责补充</p>
<p>这样可以避免产生多余的控制逻辑，提高执行效率</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

struct Node{
    int data,next;
};

int main() {
    int start,n,k;
    Node sqlist[100000];
    scanf(&quot;%d %d %d&quot;,&amp;start,&amp;n,&amp;k);
    for(int i=0;i&lt;n;i++){
        int address;
        scanf(&quot;%d &quot;,&amp;address);
        scanf(&quot;%d %d&quot;,&amp;sqlist[address].data,&amp;sqlist[address].next);
    }
    int p=start;
    vector&lt;int&gt; v[3];
    while(p!=-1){
        if(sqlist[p].data &lt; 0) v[0].push_back(p);
        else if(sqlist[p].data &gt; k) v[2].push_back(p);
        else v[1].push_back(p);
        p = sqlist[p].next;
    }
    bool flag=false;
    for(int i=0;i&lt;3;i++){
        for(int j=0;j&lt;v[i].size();j++){
            if(flag){
                printf(&quot; %05d\n%05d %d&quot;,v[i][j],v[i][j],sqlist[v[i][j]].data);
            }
            else{
                printf(&quot;%05d %d&quot;,v[i][j],sqlist[v[i][j]].data);
                flag = true;
            }
        }
    }
    printf(&quot; -1&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1074 宇宙无敌加法器 (20分)]]></title>
        <id>https://dreammilk.now.sh/1074-yu-zhou-wu-di-jia-fa-qi-20-fen/</id>
        <link href="https://dreammilk.now.sh/1074-yu-zhou-wu-di-jia-fa-qi-20-fen/">
        </link>
        <updated>2020-06-10T04:44:56.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。</p>
<p>在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出两个 PAT 数之和。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">30527
06203
415
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">7201
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目没有什么比较绕的地方：</p>
<blockquote>
<p>先将数字都与进制位数对齐，不足的前面补零</p>
<p>然后像题干中的运算过程一样，统计当前位的数字以及是否进位</p>
<p>最后得出运算结果输出即可</p>
</blockquote>
<p>一些需要注意的地方：</p>
<blockquote>
<p>进制中的0是10，使用时需要稍微加工一下</p>
<p>对于首位相加进位，需要记得在结果前面添加<code>1</code>，（PS：两个数相加进位不可能是2）</p>
<p>结果为全零时，需要输出0</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;

int main() {
    string jz,n,m;
    cin &gt;&gt; jz &gt;&gt; n &gt;&gt; m;
    m.insert(0,jz.length()-m.length(),'0');
    n.insert(0,jz.length()-n.length(),'0');
    reverse(n.begin(),n.end());
    reverse(m.begin(),m.end());
    reverse(jz.begin(),jz.end());
    int up=0;string str;
    for(int i=0;i&lt;jz.length();i++){
        int j = jz[i]=='0'?10:jz[i]-'0';
        int num = (n[i]-'0'+m[i]-'0'+up)%j;
        up = (n[i]-'0'+m[i]-'0'+up)/j;
        str.insert(0,1,num+'0');
    }
    if(up!=0) str = '1'+str;
    bool flag = false;
    for(int i=0;i&lt;str.length();i++){
        if(str[i]!='0' || flag){
            flag = true;
            cout &lt;&lt; str[i];
        }
    }
    if(!flag) printf(&quot;0&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1073 多选题常见计分法 (20分)]]></title>
        <id>https://dreammilk.now.sh/1073-duo-xuan-ti-chang-jian-ji-fen-fa-20-fen/</id>
        <link href="https://dreammilk.now.sh/1073-duo-xuan-ti-chang-jian-ji-fen-fa-20-fen/">
        </link>
        <updated>2020-06-09T04:28:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 <code>(选中的选项个数 选项1 ……)</code>，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：<code>错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号</code>。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 <code>Too simple</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">3 4 
3 4 2 a c
2 5 1 b
5 3 2 b c
1 5 4 a b d e
(2 a c) (3 b d e) (2 a c) (3 a b e)
(2 a c) (1 b) (2 a b) (4 a b d e)
(2 b d) (1 e) (1 c) (4 a b c d)
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">3.5
6.0
2.5
2 2-e
2 3-a
2 3-b
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">2 2 
3 4 2 a c
2 5 1 b
(2 a c) (1 b)
(2 a c) (1 b)
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">5.0
5.0
Too simple
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目是<code>1058 选择题</code>的升级版，不仅需要判断对错，还需要找出什么选项出现错误：</p>
<blockquote>
<p>先说明一下三种运算：异或、与、或</p>
<p>异或^运算：当两个数不同时取1，相同时取0</p>
<p>与&amp;运算：当两个数全1时取1，其余情况取0</p>
<p>或 | 运算：只有两个数全0时取0，其余情况取1</p>
<p>本题关于判断题目选项错误以及错误点便可以采取以上运算</p>
<p>先采用异或运算，通过是否全0判断错误，并标出错误选项</p>
<p>再通过与运算，通过和正确选项对比，判断是否存在多选的情况</p>
<p>然后通过或运算，判断错误选项分别是哪几个</p>
<p>举个栗子：选项答案为BC（01100），学生答案为AC（10100）</p>
<p>异或（11000）存在错误---&gt;与（00100）存在多选---&gt;或运算判断存在A（错选）B（漏选）错误</p>
<p>具体细节观察代码，自行推演计算</p>
</blockquote>
<p>存储变量的含义：</p>
<blockquote>
<p><code>fullscre</code>存储每个题目的分值；<code>trueopt</code>存储每个题目的选项和</p>
<p><code>cnt</code>存储每个题目的每个选项的错误次数；<code>opt</code>存储每个学生的每个题目的选项和</p>
</blockquote>
<p>整个题目的重难点主要在于判断哪些选项错误，其余的细节基本与<a href="https://dreammilk.now.sh/1058-xuan-ze-ti-20-fen/"><code>1058 选择题</code></a>类似</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
int main() {
    int n, m, optnum, truenum, temp, maxcnt = 0;
    int hash[] = {1, 2, 4, 8, 16}, opt[1010][110] = {0};
    char c;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    vector&lt;int&gt; fullscore(m), trueopt(m);
    vector&lt;vector&lt;int&gt;&gt; cnt(m, vector&lt;int&gt;(5));
    for (int i = 0; i &lt; m; i++) {
        scanf(&quot;%d %d %d&quot;, &amp;fullscore[i], &amp;optnum, &amp;truenum);
        for (int j = 0; j &lt; truenum; j++) {
            scanf(&quot; %c&quot;, &amp;c);
            trueopt[i] += hash[c-'a'];
        }
    }
    for (int i = 0; i &lt; n; i++) {
        double grade = 0;
        for (int j = 0; j &lt; m; j++) {
            getchar();
            scanf(&quot;(%d&quot;, &amp;temp);
            for (int k = 0; k &lt; temp; k++) {
                scanf(&quot; %c)&quot;, &amp;c);
                opt[i][j] += hash[c-'a'];
            }
            int el = opt[i][j] ^ trueopt[j];
            if (el) {
                if ((opt[i][j] | trueopt[j]) == trueopt[j]) {
                    grade += fullscore[j] * 1.0 / 2;
                }
                if (el) {
                    for (int k = 0; k &lt; 5; k++)
                        if (el &amp; hash[k]) cnt[j][k]++;
                }
            } else {
                grade += fullscore[j];
            }
        }
        printf(&quot;%.1f\n&quot;, grade);
    }
    for (int i = 0; i &lt; m; i++)
        for (int j = 0; j &lt; 5; j++)
            maxcnt = maxcnt &gt; cnt[i][j] ? maxcnt : cnt[i][j];

    if (maxcnt == 0) {
        printf(&quot;Too simple\n&quot;);
    } else {
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; cnt[i].size(); j++) {
                if (maxcnt == cnt[i][j])
                    printf(&quot;%d %d-%c\n&quot;, maxcnt, i+1, 'a'+j);
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1072 开学寄语 (20分)]]></title>
        <id>https://dreammilk.now.sh/1072-kai-xue-ji-yu-20-fen/</id>
        <link href="https://dreammilk.now.sh/1072-kai-xue-ji-yu-20-fen/">
        </link>
        <updated>2020-06-08T03:44:57.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="jiyu.JPG" loading="lazy"></figure>
<p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/3b1d9f4a-778b-4942-a9e2-836262f363aa.JPG" alt="jiyu.JPG" loading="lazy"></figure>
<p>本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）：</p>
<pre><code class="language-in">姓名缩写: 物品编号1 物品编号2 ……
</code></pre>
<p>最后一行输出存在问题的学生的总人数和被查缴物品的总数。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">4 2
2333 6666
CYLL 3 1234 2345 3456
U 4 9966 6666 8888 6666
GG 2 2333 7777
JJ 3 0012 6666 2333
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">U: 6666 6666
GG: 2333
JJ: 6666 2333
3 5
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>将输入的违禁品编号使用<code>bool ban[10000]</code>进行存储，不属于违禁品的默认false</p>
<p>循环遍历学生以及携带物品，使用flag判断学生是否携带违禁品，并利用stu统计违规学生，cnt统计违禁品数量</p>
<p>flag还可以控制是否输出过名字，保证输出格式规范</p>
</blockquote>
<p>对于违禁品编号的存储：</p>
<blockquote>
<p>一开始发现题目中说明违禁品数量不超过6个，于是决定选择使用map存储</p>
<p>但是运行的时候发现，使用map存储的耗时要比数组慢很多，但是空间使用却没有太大的区别</p>
</blockquote>
<p>数组与map相比，还是数组香，因此在相同情况下还是选择使用数组会比较好</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

int main() {
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    bool ban[10000]={false};
    for(int i=0;i&lt;m;i++){
        int id;
        scanf(&quot;%d&quot;,&amp;id);
        ban[id]=true;
    }
    int cnt=0,stu=0;
    for(int i=0;i&lt;n;i++){
        char name[10];
        int num;
        bool flag=true;
        scanf(&quot;%s %d&quot;,&amp;name,&amp;num);
        for(int j=0;j&lt;num;j++){
            int id;
            scanf(&quot;%d&quot;,&amp;id);
            if(ban[id] &amp;&amp; flag){
                printf(&quot;%s: %04d&quot;,name,id);
                cnt++;
                flag = false;
            }else if(ban[id]){
                printf(&quot; %04d&quot;,id);
                cnt++;
            }
        }
        if(!flag){
            stu++;
            printf(&quot;\n&quot;);
        }
    }
    printf(&quot;%d %d\n&quot;,stu,cnt);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1071 小赌怡情 (15分)]]></title>
        <id>https://dreammilk.now.sh/1071-xiao-du-yi-qing-15-fen/</id>
        <link href="https://dreammilk.now.sh/1071-xiao-du-yi-qing-15-fen/">
        </link>
        <updated>2020-06-07T04:10:57.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p>
<p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。</p>
<p>注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字：</p>
<pre><code class="language-in">n1 b t n2
</code></pre>
<p>其中 <code>n1</code> 和 <code>n2</code> 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。<code>b</code> 为 0 表示玩家赌<code>小</code>，为 1 表示玩家赌<code>大</code>。<code>t</code> 表示玩家下注的筹码数，保证在整型范围内。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对每一次游戏，根据下列情况对应输出（其中 <code>t</code> 是玩家下注量，<code>x</code> 是玩家当前持有的筹码量）：</p>
<ul>
<li>玩家赢，输出 <code>Win t! Total = x.</code>；</li>
<li>玩家输，输出 <code>Lose t. Total = x.</code>；</li>
<li>玩家下注超过持有的筹码量，输出 <code>Not enough tokens. Total = x.</code>；</li>
<li>玩家输光后，输出 <code>Game Over.</code> 并结束程序。</li>
</ul>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">100 4
8 0 100 2
3 1 50 1
5 1 200 6
7 0 200 8
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">Win 100!  Total = 200.
Lose 50.  Total = 150.
Not enough tokens.  Total = 150.
Not enough tokens.  Total = 150.
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">100 4
8 0 100 2
3 1 200 1
5 1 200 6
7 0 200 8
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">Win 100!  Total = 200.
Lose 200.  Total = 0.
Game Over.
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>每次先比较当前筹码与是否能够下注，如果能够下注继续判断输赢情况</p>
<p>如果本局输了之后筹码归零，则直接退出程序</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;

using namespace std;

int main() {
    int T,k;
    cin &gt;&gt; T &gt;&gt; k;
    for(int i=0;i&lt;k;i++){
        int n1,b,t,n2;
        scanf(&quot;%d %d %d %d&quot;,&amp;n1,&amp;b,&amp;t,&amp;n2);
        if(T &lt; t) printf(&quot;Not enough tokens.  Total = %d.\n&quot;,T);
        else{
            if((n1 &lt; n2&amp;&amp;b==1)  || (n1 &gt; n2&amp;&amp;b==0)){
                T += t;
                printf(&quot;Win %d!  Total = %d.\n&quot;,t,T);
            }
            else{
                T -= t;
                printf(&quot;Lose %d.  Total = %d.\n&quot;,t,T);
            }
            if(T == 0){
                printf(&quot;Game Over.&quot;);
                break;
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1070 结绳 (25分)]]></title>
        <id>https://dreammilk.now.sh/1070-jie-sheng-25-fen/</id>
        <link href="https://dreammilk.now.sh/1070-jie-sheng-25-fen/">
        </link>
        <updated>2020-06-06T04:31:25.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt="rope.jpg" loading="lazy"></figure>
<p>给定 <em>N</em> 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/46293e57-aa0e-414b-b5c3-7c4b2d5201e2.jpg" alt="rope.jpg" loading="lazy"></figure>
<p>给定 <em>N</em> 段绳子的长度，你需要找出它们能串成的绳子的最大长度。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 <em>N</em> (2≤<em>N</em>≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>)；第 2 行给出 <em>N</em> 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">8
10 15 12 3 4 13 1 15
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">14
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目求串成的绳子的最大长度：</p>
<blockquote>
<p>因为n个绳子变为一根绳子一定会经过n-1次结绳，为防止对折损失的长度最小，应从短绳开始进行结绳</p>
</blockquote>
<p>有了上面的想法就比较容易了：</p>
<blockquote>
<p>将输入的数字按从小到大的顺序进行排序，然后每次将两个绳子相加除二，最终所得长度即为最大长度</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

using namespace std;

int main() {
    int m;
    cin &gt;&gt; m;
    vector&lt;int&gt; v(m);
    for(int i=0;i&lt;m;i++){
        cin &gt;&gt; v[i];
    }
    sort(v.begin(),v.end());
    int length=v[0];
    for(int i=1;i&lt;m;i++){
        length = (length+v[i])/2;
    }
    cout &lt;&lt; length;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1069 微博转发抽奖 (20分)]]></title>
        <id>https://dreammilk.now.sh/1069-wei-bo-zhuan-fa-chou-jiang-20-fen/</id>
        <link href="https://dreammilk.now.sh/1069-wei-bo-zhuan-fa-chou-jiang-20-fen/">
        </link>
        <updated>2020-06-05T03:57:57.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。</p>
<p>注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 <code>Keep going...</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">9 3 2
Imgonnawin!
PickMe
PickMeMeMeee
LookHere
Imgonnawin!
TryAgainAgain
TryAgainAgain
Imgonnawin!
TryAgainAgain
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">PickMe
Imgonnawin!
TryAgainAgain
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">2 3 5
Imgonnawin!
PickMe
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">Keep going...
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>当总人数小于第一位中奖者号码时，说明无人中奖</p>
<p>使用<code>map</code>记录每个id的出现次数，避免重复参与抽奖</p>
<p>然后根据题目逻辑进行判断处理</p>
</blockquote>
<p>对于题目逻辑可能有点争议：</p>
<blockquote>
<p>对于是选择到中奖者后判断是否重复；还是每一个都要判断是否重复，然后顺取下一位</p>
<p>这两种写法都可以通过测试，应该是样例数据的问题，题目的意思应该为前者</p>
</blockquote>
<p>这个问题在写代码时浑然不知，复盘一遍还是能够发现代码的不足之处😁</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;map&gt;

using namespace std;

int main() {
    int m,n,s;
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; s;
    map&lt;string,int&gt; mp;
    if(m&lt;s) cout &lt;&lt; &quot;Keep going...&quot;;
    for(int i=1;i&lt;=m;i++){
        string id;
        cin &gt;&gt; id;
        if(i==s &amp;&amp; mp[id]==0){
            cout &lt;&lt; id &lt;&lt; endl;
            mp[id]++;
            s += n;
        }
        else if(i==s &amp;&amp; mp[id]!=0) s++;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1068 万绿丛中一点红 (20分)]]></title>
        <id>https://dreammilk.now.sh/1068-wan-lu-cong-zhong-yi-dian-hong-20-fen/</id>
        <link href="https://dreammilk.now.sh/1068-wan-lu-cong-zhong-yi-dian-hong-20-fen/">
        </link>
        <updated>2020-06-04T04:59:09.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 <em>M</em>×<em>N</em> 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 <em>M</em>×<em>N</em> 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出三个正整数，分别是 <em>M</em> 和 <em>N</em>（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 <em>N</em> 行，每行给出 <em>M</em> 个像素的颜色值，范围在 [0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup></mrow><annotation encoding="application/x-tex">2^{24}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>) 内。所有同行数字间用空格或 TAB 分开。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中按照 <code>(x, y): color</code> 的格式输出所求像素点的位置以及颜色值，其中位置 <code>x</code> 和 <code>y</code> 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 <code>Not Unique</code>；如果这样的点不存在，则输出 <code>Not Exist</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">8 6 200
0 	 0 	  0 	   0	    0 	     0 	      0        0
65280 	 65280    65280    16711479 65280    65280    65280    65280
16711479 65280    65280    65280    16711680 65280    65280    65280
65280 	 65280    65280    65280    65280    65280    165280   165280
65280 	 65280 	  16777015 65280    65280    165280   65480    165280
16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">(5, 3): 16711680
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">4 5 2
0 0 0 0
0 0 3 0
0 0 0 0
0 5 0 0
0 0 0 0
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">Not Unique
</code></pre>
<h3 id="输入样例3">输入样例3：</h3>
<pre><code class="language-in">3 3 5
1 2 3
3 4 5
5 6 7
</code></pre>
<h3 id="输出样例3">输出样例3：</h3>
<pre><code class="language-out">Not Exist
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目一开始例子没怎么看懂：</p>
<blockquote>
<p>一直在纠结<code>16711479</code>为什么不符合要求，原来首要条件是像素点颜色只能出现一次</p>
</blockquote>
<p>做题思路：</p>
<blockquote>
<p>因为需要统计颜色是否出现过一次，所以使用了<code>map</code>结构</p>
<p>可能会觉得这为什么不用数组结构了呢，因为题目输入的大部分数据重复率很高，不像随机散乱的数据</p>
<p>将输入的像素点用二维数组进行存储，并使用<code>map</code>统计出现次数</p>
<p>然后遍历二维数组，将只出现一次并与周围相差较大的像素点的行、列数保存，符合要求的个数加一</p>
<p>最后判断是否只存在一个要求，按照题意进行输出</p>
</blockquote>
<p>对于行列数不用担心覆盖的情况，如果覆盖说明不唯一，否则不会存在覆盖现象</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;map&gt;

using namespace std;

int m,n,tol;
vector&lt;vector&lt;int&gt;&gt; v;
int r[8][2]={{-1,-1},{0,-1},{1,-1},{-1,0},{1,0},{-1,1},{0,1},{1,1}};

bool round(int i,int j){
    for(int k=0;k&lt;8;k++){
        int x=i+r[k][0];
        int y=j+r[k][1];
        if(x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m&amp;&amp;v[i][j]-v[x][y]&gt;=0-tol&amp;&amp;v[i][j]-v[x][y]&lt;=tol) return false;
    }
    return true;

}

int main() {
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; tol;
    v.resize(n,vector&lt;int&gt;(m));
    map&lt;int,int&gt; M;
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;m;j++){
            cin &gt;&gt; v[i][j];
            M[v[i][j]]++;
        }
    }
    int cnt=0,x,y;
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;m;j++){
            if(M[v[i][j]]==1 &amp;&amp; round(i,j)){
                x = i+1;
                y = j+1;
                cnt++;
            }
        }
    }
    if(cnt==1) printf(&quot;(%d, %d): %d&quot;,y,x,v[x-1][y-1]);
    else if(cnt &gt; 1) printf(&quot;Not Unique&quot;);
    else printf(&quot;Not Exist&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>