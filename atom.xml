<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dreammilk.now.sh</id>
    <title>Milk &apos;s Home</title>
    <updated>2020-06-22T04:14:39.501Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dreammilk.now.sh"/>
    <link rel="self" href="https://dreammilk.now.sh/atom.xml"/>
    <subtitle>welcome</subtitle>
    <logo>https://dreammilk.now.sh/images/avatar.png</logo>
    <icon>https://dreammilk.now.sh/favicon.ico</icon>
    <rights>All rights reserved 2020, Milk &apos;s Home</rights>
    <entry>
        <title type="html"><![CDATA[1086 就不告诉你 (15分)]]></title>
        <id>https://dreammilk.now.sh/1086-jiu-bu-gao-su-ni-15-fen/</id>
        <link href="https://dreammilk.now.sh/1086-jiu-bu-gao-su-ni-15-fen/">
        </link>
        <updated>2020-06-22T04:07:56.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/0c3a4497-27c3-45ea-9c8e-5a1ab2df48af.jpg" alt="53.jpg" loading="lazy"></figure>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。</p>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/0c3a4497-27c3-45ea-9c8e-5a1ab2df48af.jpg" alt="53.jpg" loading="lazy"></figure>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中倒着输出 A 和 B 的乘积。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">5 7
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">53
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目输出两个数字乘积的倒序：</p>
<blockquote>
<p>唯一需要注意的地方是乘积倒序后开头为0的情况，需要跳过这些0，从第一个非0数字开始输出</p>
</blockquote>
<p>剩余的就是<code>%10</code>的基本操作</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int a,b,mul,num;
    cin &gt;&gt; a &gt;&gt; b;
    mul = a*b;
    bool flag = true;
    while(mul!=0){
        num = mul%10;
        if(num != 0){
            cout &lt;&lt; num;
            flag=false;
        }
        else if(!flag) cout &lt;&lt; num;
        mul /=10;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1085 PAT单位排行 (25分)]]></title>
        <id>https://dreammilk.now.sh/1085-pat-dan-wei-pai-xing-25-fen/</id>
        <link href="https://dreammilk.now.sh/1085-pat-dan-wei-pai-xing-25-fen/">
        </link>
        <updated>2020-06-20T04:20:02.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个正整数 N（≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息：</p>
<pre><code class="language-markdown">准考证号 得分 学校
</code></pre>
<p>其中<code>准考证号</code>是由 6 个字符组成的字符串，其首字母表示考试的级别：<code>B</code>代表乙级，<code>A</code>代表甲级，<code>T</code>代表顶级；<code>得分</code>是 [0, 100] 区间内的整数；<code>学校</code>是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜：</p>
<pre><code class="language-markdown">排名 学校 加权总分 考生人数
</code></pre>
<p>其中<code>排名</code>是该单位的排名（从 1 开始）；<code>学校</code>是全部按小写字母输出的单位码；<code>加权总分</code>定义为<code>乙级总分/1.5 + 甲级总分 + 顶级总分*1.5</code>的<strong>整数部分</strong>；<code>考生人数</code>是该属于单位的考生的总人数。</p>
<p>学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">10
A57908 85 Au
B57908 54 LanX
A37487 60 au
T28374 67 CMU
T32486 24 hypu
A66734 92 cmu
B76378 71 AU
A47780 45 lanx
A72809 100 pku
A03274 45 hypu
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">5
1 cmu 192 2
1 au 192 3
3 pku 100 1
4 hypu 81 2
4 lanx 81 2
</code></pre>
<h3 id="思路">思路：</h3>
<p>读题感觉难度不高，写起来真费脑子🧠：</p>
<blockquote>
<p>首先选择使用两个<code>map</code>结构分别存放考生人数与学校加权总分，使用<code>vector</code>存放最后输出内容</p>
<p>学校名称需要统一小写后存放，然后根据考试级别统计各学校加权总分，于是得到了两个<code>map</code>的数据</p>
<p>然后根据两个<code>map</code>数据统计每个学校<code>名字 加权总分 考生人数</code>汇总到<code>vector</code>中</p>
<p>接着根据题目提供的排序逻辑进行排序，然后通过判断语句输出相应的排名数</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;cctype&gt;
#include &lt;algorithm&gt;

using namespace std;

struct node{
    string name;
    int score=0,number=0;
};

bool cmp(node a,node b){
    if(a.score!=b.score) return a.score&gt;b.score;
    else if(a.number!=b.number) return a.number&lt;b.number;
    else return a.name&lt;b.name;
}

int main() {
    int n;
    cin &gt;&gt; n;
    map&lt;string,int&gt; cnt;
    map&lt;string,float&gt; s;
    vector&lt;node&gt; v;
    for(int i=0;i&lt;n;i++){
        string tid,school;
        float score;
        cin &gt;&gt; tid &gt;&gt; score &gt;&gt; school;
        for(int j=0;j&lt;school.length();j++)
        {
            school[j] = tolower(school[j]);
        }
        if(tid[0]=='A') s[school] += score;
        if(tid[0]=='B') s[school] += score/1.5;
        if(tid[0]=='T') s[school] += score*1.5;
        cnt[school]++;
    }
    for(auto it=s.begin();it!=s.end();it++){
        node no;
        no.name=it-&gt;first;
        no.number=cnt[no.name];
        no.score=it-&gt;second;
        v.push_back(no);
    }
    sort(v.begin(),v.end(),cmp);
    cout &lt;&lt; v.size() &lt;&lt; endl;
    int temp=-1;int Rank=1;
    for(int i=0;i&lt;v.size();i++){
        if(v[i].score!=temp){
            Rank = i+1;
            temp = v[i].score;
        }
        cout &lt;&lt; Rank &lt;&lt; ' ' &lt;&lt; v[i].name &lt;&lt; ' ' &lt;&lt; v[i].score &lt;&lt; ' ' &lt;&lt; v[i].number &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[需复盘]1084 外观数列 (20分)]]></title>
        <id>https://dreammilk.now.sh/xu-fu-pan-1084-wai-guan-shu-lie-20-fen/</id>
        <link href="https://dreammilk.now.sh/xu-fu-pan-1084-wai-guan-shu-lie-20-fen/">
        </link>
        <updated>2020-06-19T04:10:56.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>外观数列是指具有以下特点的整数序列：</p>
<pre><code>d, d1, d111, d113, d11231, d112213111, ...
</code></pre>
<p>它从不等于 1 的数字 <code>d</code> 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 <code>d</code>，所以就是 <code>d1</code>；第 2 项是 1 个 <code>d</code>（对应 <code>d1</code>）和 1 个 1（对应 11），所以第 3 项就是 <code>d111</code>。又比如第 4 项是 <code>d113</code>，其描述就是 1 个 <code>d</code>，2 个 1，1 个 3，所以下一项就是 <code>d11231</code>。当然这个定义对 <code>d</code> = 1 也成立。本题要求你推算任意给定数字 <code>d</code> 的外观数列的第 N 项。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>外观数列是指具有以下特点的整数序列：</p>
<pre><code>d, d1, d111, d113, d11231, d112213111, ...
</code></pre>
<p>它从不等于 1 的数字 <code>d</code> 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 <code>d</code>，所以就是 <code>d1</code>；第 2 项是 1 个 <code>d</code>（对应 <code>d1</code>）和 1 个 1（对应 11），所以第 3 项就是 <code>d111</code>。又比如第 4 项是 <code>d113</code>，其描述就是 1 个 <code>d</code>，2 个 1，1 个 3，所以下一项就是 <code>d11231</code>。当然这个定义对 <code>d</code> = 1 也成立。本题要求你推算任意给定数字 <code>d</code> 的外观数列的第 N 项。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出 [0,9] 范围内的一个整数 <code>d</code>、以及一个正整数 N（≤ 40），用空格分隔。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中给出数字 <code>d</code> 的外观数列的第 N 项。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">1 8
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">1123123111
</code></pre>
<h3 id="思路">思路：</h3>
<p>目前没有理解为什么会出现测试点无法通过的点</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n;
    string d;
    cin &gt;&gt; d &gt;&gt; n;
    for(int i=1;i&lt;n;i++){
        string str=&quot;&quot;;
        char temp = d[0];int cnt = 1;
        for(int j=1;j&lt;d.length();j++){
            if(d[j]==temp) cnt++;
            else{
                str = str+temp+char('0'+cnt);
                cnt = 1;
                temp=d[j];
            }
        }
        str = str+temp+char('0'+cnt);
        d = str;
    }
    cout &lt;&lt; d &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>修改后：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    string s;
    int n, j;
    cin &gt;&gt; s &gt;&gt; n;
    for (int cnt = 1; cnt &lt; n; cnt++) {
        string t;
        for (int i = 0; i &lt; s.length(); i = j) {
            for (j = i; j &lt; s.length() &amp;&amp; s[j] == s[i]; j++);
            t += s[i] + to_string(j - i);
        }
        s = t;
    }
    cout &lt;&lt; s;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1082 射击比赛 (20分)]]></title>
        <id>https://dreammilk.now.sh/1082-she-ji-bi-sai-20-fen/</id>
        <link href="https://dreammilk.now.sh/1082-she-ji-bi-sai-20-fen/">
        </link>
        <updated>2020-06-18T04:07:31.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出：</p>
<pre><code>ID x y
</code></pre>
<p>其中 <code>ID</code> 是运动员的编号（由 4 位数字组成）；<code>x</code> 和 <code>y</code> 是其打出的弹洞的平面坐标(<code>x</code>,<code>y</code>)，均为整数，且 0 ≤ |<code>x</code>|, |<code>y</code>| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">3
0001 5 7
1020 -1 3
0233 0 -1
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">0233 0001
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目主要还是找最大最小值：</p>
<blockquote>
<p>对于距离还是直接使用<code>x*x+y*y</code>进行比较</p>
<p>找到最大最小值时需要保存他们的id</p>
<p>最后直接输出最小值id与最大值id</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n,MAX=0,MIN=10000,maxid,minid;
    cin &gt;&gt; n;
    for(int i=0;i&lt;n;i++){
        int id,x,y,length;
        cin &gt;&gt; id &gt;&gt; x &gt;&gt; y;
        length = x*x+y*y;
        if(length &gt; MAX){
            MAX = length;
            maxid = id;
        }
        if(length &lt; MIN){
            MIN = length;
            minid = id;
        }
    }
    printf(&quot;%04d %04d&quot;,minid,maxid);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1081 检查密码 (15分)]]></title>
        <id>https://dreammilk.now.sh/1081-jian-cha-mi-ma-15-fen/</id>
        <link href="https://dreammilk.now.sh/1081-jian-cha-mi-ma-15-fen/">
        </link>
        <updated>2020-06-17T04:16:44.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 <code>.</code>，还必须既有字母也有数字。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 <code>.</code>，还必须既有字母也有数字。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对每个用户的密码，在一行中输出系统反馈信息，分以下5种：</p>
<ul>
<li>如果密码合法，输出<code>Your password is wan mei.</code>；</li>
<li>如果密码太短，不论合法与否，都输出<code>Your password is tai duan le.</code>；</li>
<li>如果密码长度合法，但存在不合法字符，则输出<code>Your password is tai luan le.</code>；</li>
<li>如果密码长度合法，但只有字母没有数字，则输出<code>Your password needs shu zi.</code>；</li>
<li>如果密码长度合法，但只有数字没有字母，则输出<code>Your password needs zi mu.</code>。</li>
</ul>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">5
123s
zheshi.wodepw
1234.5678
WanMei23333
pass*word.6
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">Your password is tai duan le.
Your password needs shu zi.
Your password needs zi mu.
Your password is wan mei.
Your password is tai luan le.
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目的输出格式将逻辑展示的非常清楚：</p>
<blockquote>
<p>对每一个字符串，首先判断字符长度，过短则输出</p>
<p>对字符串的每一个字符进行判断，使用<code>bool</code>变量检测数字和字母是否出现（在字符遍历完后判断）</p>
<p>如果出现不规范的字符则直接停止字符遍历，进行输出；否则继续遍历</p>
</blockquote>
<p>注意一点：</p>
<blockquote>
<p>题目虽然没有明确提醒输入时会有空格，但是需要考虑这种情况，避免测试点无法通过</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cctype&gt;

using namespace std;

int main() {
    int n;
    scanf(&quot;%d\n&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        string str;
        getline(cin,str);
        if(str.length() &lt; 6){
            cout &lt;&lt; &quot;Your password is tai duan le.&quot; &lt;&lt; endl;
            continue;
        }
        else{
            int j;
            bool number=true,alpha=true;
            for(j=0;j&lt;str.length();j++){
                if(isdigit(str[j])) number=false;
                else if(isalpha(str[j])) alpha = false;
                else if(str[j]=='.') continue;
                else{
                    cout &lt;&lt; &quot;Your password is tai luan le.&quot; &lt;&lt; endl;
                    break;
                }
            }
            if(j!=str.length()) continue;
            if(number){
                cout &lt;&lt; &quot;Your password needs shu zi.&quot; &lt;&lt; endl;
                continue;
            }
            if(alpha){
                cout &lt;&lt; &quot;Your password needs zi mu.&quot; &lt;&lt; endl;
                continue;
            }
            cout &lt;&lt; &quot;Your password is wan mei.&quot; &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1079 延迟的回文数 (20分)]]></title>
        <id>https://dreammilk.now.sh/1079-yan-chi-de-hui-wen-shu-20-fen/</id>
        <link href="https://dreammilk.now.sh/1079-yan-chi-de-hui-wen-shu-20-fen/">
        </link>
        <updated>2020-06-15T03:30:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个 <em>k</em>+1 位的正整数 <em>N</em>，写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>⋯<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_1a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的形式，其中对所有 <em>i</em> 有 0≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&lt;10 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&gt;0。<em>N</em> 被称为一个<strong>回文数</strong>，当且仅当对所有 <em>i</em> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>−<em>i</em>。零也被定义为一个回文数。</p>
<p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为<strong>延迟的回文数</strong>。（定义翻译自 https://en.wikipedia.org/wiki/Palindromic_number ）</p>
<p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个 <em>k</em>+1 位的正整数 <em>N</em>，写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>⋯<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_1a_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的形式，其中对所有 <em>i</em> 有 0≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&lt;10 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&gt;0。<em>N</em> 被称为一个<strong>回文数</strong>，当且仅当对所有 <em>i</em> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>−<em>i</em>。零也被定义为一个回文数。</p>
<p>非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为<strong>延迟的回文数</strong>。（定义翻译自 https://en.wikipedia.org/wiki/Palindromic_number ）</p>
<p>给定任意一个正整数，本题要求你找到其变出的那个回文数。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入在一行中给出一个不超过1000位的正整数。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对给定的整数，一行一行输出其变出回文数的过程。每行格式如下</p>
<pre><code class="language-markdown">A + B = C
</code></pre>
<p>其中 <code>A</code> 是原始的数字，<code>B</code> 是 <code>A</code> 的逆转数，<code>C</code> 是它们的和。<code>A</code> 从输入的整数开始。重复操作直到 <code>C</code> 在 10 步以内变成回文数，这时在一行中输出 <code>C is a palindromic number.</code>；或者如果 10 步都没能得到回文数，最后就在一行中输出 <code>Not found in 10 iterations.</code>。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">97152
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">97152 + 25179 = 122331
122331 + 133221 = 255552
255552 is a palindromic number.
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">196
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">196 + 691 = 887
887 + 788 = 1675
1675 + 5761 = 7436
7436 + 6347 = 13783
13783 + 38731 = 52514
52514 + 41525 = 94039
94039 + 93049 = 187088
187088 + 880781 = 1067869
1067869 + 9687601 = 10755470
10755470 + 07455701 = 18211171
Not found in 10 iterations.
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目隐藏的意思：</p>
<blockquote>
<p>如果输入的数字就是回文数的话，直接输出<code>C is a palindromic number.</code></p>
</blockquote>
<p>大致过程：</p>
<blockquote>
<p>进行10次循环，每次先对输入字符串判断是否为回文数，如果是则退出，否则下一步</p>
<p>然后输出等式并将字符串与反转字符串相加，得到新的字符串</p>
<p>结束循环后判断是否是中途退出循环，如果是则符合回文要求，否则不能得到回文数</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
    string input,str;
    cin &gt;&gt; str;
    int i;
    for(i=0;i&lt;10;i++){
        input = str;
        reverse(str.begin(),str.end());
        if(input == str){
            cout &lt;&lt; input &lt;&lt; &quot; is a palindromic number.&quot;;
            break;
        }
        cout &lt;&lt; input &lt;&lt; &quot; + &quot;;

        cout &lt;&lt; str &lt;&lt; &quot; = &quot;;
        int up=0;str=&quot;&quot;;
        for(int j=0;j&lt;input.length();j++){
            char c;
            int num=input[j]+input[input.length()-1-j]-2*'0'+up;
            c = num%10+'0';
            up = num/10;
            str = c+str;
        }
        if(up!=0) str = &quot;1&quot;+str;
        cout &lt;&lt; str &lt;&lt; endl;
    }
    if(i==10) cout &lt;&lt; &quot;Not found in 10 iterations.&quot;;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1078 字符串压缩与解压 (20分)]]></title>
        <id>https://dreammilk.now.sh/1078-zi-fu-chuan-ya-suo-yu-jie-ya-20-fen/</id>
        <link href="https://dreammilk.now.sh/1078-zi-fu-chuan-ya-suo-yu-jie-ya-20-fen/">
        </link>
        <updated>2020-06-14T04:25:53.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 <code>ccccc</code> 就用 <code>5c</code> 来表示。如果字符没有重复，就原样输出。例如 <code>aba</code> 压缩后仍然是 <code>aba</code>。</p>
<p>解压方法就是反过来，把形如 <code>5c</code> 这样的表示恢复为 <code>ccccc</code>。</p>
<p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 <code>ccccc</code> 就用 <code>5c</code> 来表示。如果字符没有重复，就原样输出。例如 <code>aba</code> 压缩后仍然是 <code>aba</code>。</p>
<p>解压方法就是反过来，把形如 <code>5c</code> 这样的表示恢复为 <code>ccccc</code>。</p>
<p>本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个字符，如果是 <code>C</code> 就表示下面的字符串需要被压缩；如果是 <code>D</code> 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>根据要求压缩或解压字符串，并在一行中输出结果。</p>
</blockquote>
<h3 id="输入样例1">输入样例1：</h3>
<pre><code class="language-in">C
TTTTThhiiiis isssss a   tesssst CAaaa as
</code></pre>
<h3 id="输出样例1">输出样例1：</h3>
<pre><code class="language-out">5T2h4is i5s a3 te4st CA3a as
</code></pre>
<h3 id="输入样例2">输入样例2：</h3>
<pre><code class="language-in">D
5T2h4is i5s a3 te4st CA3a as10Z
</code></pre>
<h3 id="输出样例2">输出样例2：</h3>
<pre><code class="language-out">TTTTThhiiiis isssss a   tesssst CAaaa asZZZZZZZZZZ
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较容易：</p>
<blockquote>
<p>在压缩字符串时存在两个变量，<code>temp</code>和<code>cnt</code>分别是前一个字母与出现次数</p>
<p>如果当前字母与<code>temp</code>不同，则输出<code>cnt</code>和<code>temp</code>，如果<code>cnt</code>为1则省略；不同时<code>cnt++</code></p>
<p>在解压字符串时需要注意连续出现数字的情况，这些数字需要变为一个整体</p>
<p>然后每次输出时循环打印即可</p>
</blockquote>
<p>需要注意输入输出的格式问题，避免存储错误信息</p>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cctype&gt;

using namespace std;

int main() {
    char c;
    string s;
    int cnt=0;
    cin &gt;&gt; c;
    getchar();
    getline(cin,s);
    if(c=='C'){
        char temp = s[0];
        for(int i=1;i&lt;s.length();i++){
            if(s[i]==temp) cnt++;
            else{
                if(cnt==0) cout &lt;&lt; temp;
                else cout &lt;&lt; cnt+1 &lt;&lt; temp;
                temp = s[i];
                cnt = 0;
            }
        }
        if(cnt==0) cout &lt;&lt; temp;
        else cout &lt;&lt; cnt+1 &lt;&lt; temp;
    }
    else{
        for(int i=0;i&lt;s.length();i++){
            if(isdigit(s[i])) cnt = cnt*10 + s[i]-'0';
            else{
                cnt = cnt==0?1:cnt;
                for(int j=0;j&lt;cnt;j++) cout &lt;&lt; s[i];
                cnt = 0;
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1077 互评成绩计算 (20分)]]></title>
        <id>https://dreammilk.now.sh/1077-hu-ping-cheng-ji-ji-suan-20-fen/</id>
        <link href="https://dreammilk.now.sh/1077-hu-ping-cheng-ji-ji-suan-20-fen/">
        </link>
        <updated>2020-06-13T04:49:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 <em>G</em>1；老师给这个组的评分记为 <em>G</em>2。该组得分为 (<em>G</em>1+<em>G</em>2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 <em>G</em>1；老师给这个组的评分记为 <em>G</em>2。该组得分为 (<em>G</em>1+<em>G</em>2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出两个正整数 <em>N</em>（&gt; 3）和 <em>M</em>，分别是分组数和满分，均不超过 100。随后 <em>N</em> 行，每行给出该组得到的 <em>N</em> 个分数（均保证为整型范围内的整数），其中第 1 个是老师给出的评分，后面 <em>N</em>−1 个是其他组给的评分。合法的输入应该是 [0,<em>M</em>] 区间内的整数，若不在合法区间内，则该分数须被忽略。题目保证老师的评分都是合法的，并且每个组至少会有 3 个来自同学的合法评分。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>为每个组输出其最终得分。每个得分占一行。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">6 50
42 49 49 35 38 41
36 51 50 28 -1 30
40 36 41 33 47 49
30 250 -25 27 45 31
48 0 0 50 50 1234
43 41 36 29 42 29
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">42
33
41
31
37
39
</code></pre>
<h3 id="思路">思路：</h3>
<p>唯一需要注意的是计算逻辑，需要看清楚题意：</p>
<blockquote>
<p>对输入的每行数据进行处理，寻找最大最小值，学生有效分数和数量总计，老师分数</p>
<p>计算时可以使用0.5来帮助小数进行四舍五入</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n,m;
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=0;i&lt;n;i++){
        int teacher,cnt=0,MAX=0,MIN=m;
        float students=0;
        cin &gt;&gt; teacher;
        for(int j=0;j&lt;n-1;j++){
            int score;
            cin &gt;&gt; score;
            if(score&gt;=0&amp;&amp;score&lt;=m){
                if(score &gt; MAX) MAX = score;
                if(score &lt; MIN) MIN = score;
                students += score;
                cnt++;
            }
        }
        int sum=(teacher+(students-MAX-MIN)/(cnt-2))/2+0.5;
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1076 Wifi密码 (15分)]]></title>
        <id>https://dreammilk.now.sh/1076-wifi-mi-ma-15-fen/</id>
        <link href="https://dreammilk.now.sh/1076-wifi-mi-ma-15-fen/">
        </link>
        <updated>2020-06-12T04:52:45.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。</p>
</blockquote>
<!-- more -->
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://images.ptausercontent.com/7e56be3f-caba-45f1-b9cb-38a96d44de76.jpg" alt="wifi.jpg" loading="lazy"></figure>
</blockquote>
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 <code>编号-答案</code> 的格式给出一道题的 4 个选项，<code>T</code> 表示正确选项，<code>F</code> 表示错误选项。选项间用空格分隔。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>在一行中输出 wifi 密码。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">8
A-T B-F C-F D-F
C-T B-F A-F D-F
A-F D-F C-F B-T
B-T A-F C-F D-F
B-F D-T A-F C-F
A-T C-F B-F D-F
D-T B-F C-F A-F
C-T A-F B-F D-F
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">13224143
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目比较简单：</p>
<blockquote>
<p>将每一行的输入读入时，判断正确选项并输出对应数字</p>
</blockquote>
<p>稍微注意一下输入：</p>
<blockquote>
<p>每行的回车符号与空格需要吃掉，避免错误读入</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
        scanf(&quot;\n&quot;);
        bool flag=false;
        for(int j=0;j&lt;4;j++){
            char opt,ans;
            if(!flag){
                scanf(&quot;%c-%c&quot;,&amp;opt,&amp;ans);
                flag = true;
            }
            else scanf(&quot; %c-%c&quot;,&amp;opt,&amp;ans);
            if(ans == 'T') printf(&quot;%d&quot;,opt-'A'+1);
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1075 链表元素分类 (25分)]]></title>
        <id>https://dreammilk.now.sh/1075-lian-biao-yuan-su-fen-lei-25-fen/</id>
        <link href="https://dreammilk.now.sh/1075-lian-biao-yuan-su-fen-lei-25-fen/">
        </link>
        <updated>2020-06-11T03:59:35.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<blockquote>
<p>给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。</p>
</blockquote>
<!-- more -->
<h3 id="输入格式">输入格式：</h3>
<blockquote>
<p>每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>)；以及正整数K (≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。</p>
<p>接下来有 N 行，每行格式为：</p>
<pre><code class="language-in">Address Data Next
</code></pre>
<p>其中 <code>Address</code> 是结点地址；<code>Data</code> 是该结点保存的数据，为 [<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">−10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>] 区间内的整数；<code>Next</code> 是下一结点的地址。题目保证给出的链表不为空。</p>
</blockquote>
<h3 id="输出格式">输出格式：</h3>
<blockquote>
<p>对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。</p>
</blockquote>
<h3 id="输入样例">输入样例：</h3>
<pre><code class="language-in">00100 9 10
23333 10 27777
00000 0 99999
00100 18 12309
68237 -6 23333
33218 -4 00000
48652 -2 -1
99999 5 68237
27777 11 48652
12309 7 33218
</code></pre>
<h3 id="输出样例">输出样例：</h3>
<pre><code class="language-out">33218 -4 68237
68237 -6 48652
48652 -2 12309
12309 7 00000
00000 0 99999
99999 5 23333
23333 10 00100
00100 18 27777
27777 11 -1
</code></pre>
<h3 id="思路">思路：</h3>
<p>题目依旧是按照数组结构的顺序存储：</p>
<blockquote>
<p>构造一个表示结点的结构体，存储数据和下一个结点地址，然后使用数组存放</p>
<p>总共三次循环：第一次存储输入数据；第二次将数据按照大小分类；第三次将每个类中的数据输出</p>
<p>题目的意思是将数据分为（-∞，0）、[0，K]和（K，+∞），保持输入顺序即可</p>
</blockquote>
<p>其实最关键的地方在于输出的处理：</p>
<blockquote>
<p>往常一直是非常死板的认为输出语句最多输出一行的数据，可以保持输出代码比较整洁易读</p>
<p>本题的输出却是输出两行的内容，在输出当前节点时，不需要输出后续节点地址，而是有下一个结点负责补充</p>
<p>这样可以避免产生多余的控制逻辑，提高执行效率</p>
</blockquote>
<h4 id="于是代码如下">于是代码如下：</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

struct Node{
    int data,next;
};

int main() {
    int start,n,k;
    Node sqlist[100000];
    scanf(&quot;%d %d %d&quot;,&amp;start,&amp;n,&amp;k);
    for(int i=0;i&lt;n;i++){
        int address;
        scanf(&quot;%d &quot;,&amp;address);
        scanf(&quot;%d %d&quot;,&amp;sqlist[address].data,&amp;sqlist[address].next);
    }
    int p=start;
    vector&lt;int&gt; v[3];
    while(p!=-1){
        if(sqlist[p].data &lt; 0) v[0].push_back(p);
        else if(sqlist[p].data &gt; k) v[2].push_back(p);
        else v[1].push_back(p);
        p = sqlist[p].next;
    }
    bool flag=false;
    for(int i=0;i&lt;3;i++){
        for(int j=0;j&lt;v[i].size();j++){
            if(flag){
                printf(&quot; %05d\n%05d %d&quot;,v[i][j],v[i][j],sqlist[v[i][j]].data);
            }
            else{
                printf(&quot;%05d %d&quot;,v[i][j],sqlist[v[i][j]].data);
                flag = true;
            }
        }
    }
    printf(&quot; -1&quot;);
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>